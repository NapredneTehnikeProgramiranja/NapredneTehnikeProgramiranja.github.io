#+TITLE: Napredne tehnike programiranja - Clojure
#+LANGUAGE: sr
#+SETUPFILE: org-html-themes/setup/theme-bigblow.setup
#+PROPERTY: header-args:python :session osnove_programiranja :results output :exports both
#+TAGS: za_radoznale

[[file:images/clojure_logo.png]]

#+BEGIN_QUOTE
Clojure is a dynamic, general-purpose programming language, combining
the approachability and interactive development of a scripting
language with an efficient and robust infrastructure for multithreaded
programming. Clojure is a compiled language, yet remains completely
dynamic – every feature supported by Clojure is supported at
runtime. Clojure provides easy access to the Java frameworks, with
optional type hints and type inference, to ensure that calls to Java
can avoid reflection.

Clojure is a dialect of Lisp, and shares with Lisp the code-as-data
philosophy and a powerful macro system. Clojure is predominantly a
functional programming language, and features a rich set of immutable,
persistent data structures. When mutable state is needed, Clojure
offers a software transactional memory system and reactive Agent
system that ensure clean, correct, multithreaded designs.

-- Rich Hickey (author of Clojure)
#+END_QUOTE

* Uvod

  #+BEGIN_QUOTE
  If your mind is empty, it is always ready for anything, it is open to
  everything. In the beginner's mind there are many possibilities, but
  in the expert's mind there are few.

  -- Shunryu Suzuki
  #+END_QUOTE

** Lisp

   *Lisp* ili *LISP* je porodica programskih jezika sa dugom
   istorijom. Na prvi pogled ga karakteriše prefiksna notacija i
   izrazi u zagradama. Prvobitno je specificiran 1956. godine od
   strane [[https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)][John McCarthy]]-a za potrebe njegovih istraživanja u oblasti
   veštačke inteligencije (/McCarthy/ je inače i smislio naziv
   /artificial intelligence/ - /AI/). Lisp je drugi najstariji
   programski jezik visokog nivoa, samo je /Fortran/ jednu godinu
   stariji, a poređenja radi:
   - [[https://en.wikipedia.org/wiki/C_(programming_language)][C]] se pojavio 1972.
   - [[https://en.wikipedia.org/wiki/C%252B%252B][C++]] 1983.
   - [[https://en.wikipedia.org/wiki/Python_(programming_language)][Python]] 1991 (kada i [[https://en.wikipedia.org/wiki/Visual_Basic][Visual Basic]]).
   - [[https://en.wikipedia.org/wiki/Java_(programming_language)][Java]] 1995.
   - [[https://en.wikipedia.org/wiki/C_Sharp_(programming_language)][C#]] 2000.

   Lisp je konstruisan kao matematička notacija za kompjuterske
   programe inspirisana [[https://en.wikipedia.org/wiki/Lambda_calculus][Lambda računom]]([[https://en.wikipedia.org/wiki/Alonzo_Church][Alonzo Church]]). Ovaj način
   predstave programa doneo je mnoge ideje u kompjuterske nauke:
   - strukture tipa stabla
   - automatsko upravljanje memorijom (garbage collector)
   - /dynamic typing/
   - kondicionale (grananje)
   - funkcije višeg reda
   - rekurziju i rekurzivan opis podataka
   - self-hosting kompajler
   - REPL itd.

   Veliki broj navedenih stvari inspirisao je programske jezike koji
   su nastali nakon Lisp-a (tj. skoro sve programske jezike) ali neki
   od korisnih koncepata iz Lisp-a se i dan dans smatraju naprednim i
   još uvek nisu podržani u pojedinim jezicima koji se intenzivno
   koriste.

   Matematičku formulaciju Lisp-a i koncepata koje ona donosi nadalje
   pogledajte [[../resources/perzistencija_clojure.pdf][ovde]] (poglavlja 1.1, 1.2 i 1.3).

   Pored /Clojure/ dijalekta kojim ćemo se baviti na ovom kursu tu je
   još pregršt drugih dijalekata sa raznim osobinama:

   - [[https://common-lisp.net/][Commnon Lisp]]
   - [[https://en.wikipedia.org/wiki/Scheme_(programming_language)][Scheme]]
   - [[https://www.gnu.org/software/emacs/][Emacs Lisp]]
   - [[https://en.wikipedia.org/wiki/AutoLISP][AutoLisp]]
   - [[http://www.paulgraham.com/arc.html][Arc]]
   - [[http://lfe.io/][Lisp Flovered Erlang]]
     ...

*** Scheme

    *Scheme* je jedan od najznačajnijih dijalekata Lisp-a. Dizajniran
    je od početka sa idejom funkcionalnog programiranja i minimalizma
    sa veoma moćnim mehanizmima za proširenje jezika. Prvi je
    dijalekat koji usled naglašavanja funkcionalnog programiranja
    uvodi [[https://en.wikipedia.org/wiki/Tail_call][tail call optimizaciju]]. Takođe jedan je od prvih programskih
    jezika koji imaju podržanu [[https://en.wikipedia.org/wiki/Continuation][kontinuaciju]].

    Neke od "biblija" računarske nauke i programiranja generalno su
    kao jezik-primer uzimale upravo Scheme. Jedna takva knjiga je i
    [[http://deptinfo.unice.fr/~roy/sicp.pdf][Structure and Interpretation of Computer Programs]].

    Postoji mnogo raznih dijalekata Scheme-a a ovde će biti navedena
    samo dva.

**** Chez Scheme (Cisco)

     [[https://github.com/cisco/ChezScheme][*Chez*]] je [[http://www.r6rs.org/][Scheme implementacija]] zajedno sa (moćnim) kompajlerom,
     /run time/ sistemom i bibliotekama. Koristi je kompanije Cisco a
     od skoro je /open source/.

     Ako danas želite da probate Scheme da njime rešite problem na
     kome radite a fokus Vam je na performansama, IO, konkurentnom
     programiranju ili Vam treba dobra mogućnost korišćenja postojećih
     C biblioteka onda nije loše da počnete sa *Chez*-om.

**** Racket lang

     [[https://racket-lang.org/][Racket lang]] je takođe implementacija Schema-a ali sa potpuno
     drugim ciljevima pri dizajnu. Racket je po svom dizajnu sistem za
     pravljenje programskih jezika (i/ili [[https://en.wikipedia.org/wiki/Domain-specific_language][DSL]]-ova). Ima veoma dobar
     ekosistem biblioteka (u formi jezika) za razne standardne (WEB
     serveri, GUI ...) i manje standardne zadatke. Sve njegove
     biblioteke su veoma dobro dokumentovane. Racket ima i svoje
     razvojno okruženje (IDE) DrRacket koje sadrži sve na šta ste
     navikli od jednog IDE-a (uključujući i grafički debugger). Ako je
     dizajn DSL-ova način na koji razmišljate pri rešavanju problema
     onda će Racket lang i njegovo okruženje biti odlično društvo od
     kojeg možete mnogo da naučite.

** Imperativno vs funckionalno programiranje

** Funkcionalni način razmišljanja

** Clojure u standardnim OO problemima

* Elementi jezika

** /Homoiconicy/ --- "istoizglednost"

   #+ATTR_HTML: :width 700
   #+CAPTION: [[https://twitter.com/franschm][@franschm]]
   [[file:images/franca_homoiconicy_clojure.jpg]]

   Primetimo da u jezicima koji nisu /homoikonični/ važi pravilo:

   *Kod je Kralj, podaci se zamišljaju.*

   Dok kod jezika koji su /homoikonični/ situacija nije tako
   striktna. Kod u koji gledamo su zapravo podaci, ne moramo da ih
   zamišljamo.

* REPL i IDE

* Read, evaluate vrtlog i makroi

* Konkurentno i paralelno programiranje

** Reference

** core.async

* Interakcija sa platformom

* Apstrakcije

** Multimethods

** Protocols

** Records

** clojure.spec

* ClojureScript

* Reader conditionals (.cljc)

* ClojureCLR

* Literatura
  - [[http://www.braveclojure.com/][Clojure For The Brave and True]] --- Daniel Higginbotham
  - Professional Clojure --- Anderson, Gaare, Holguin, Bailey, Pratley
  - Web Development with Clojure 2nd Edition --- Dmitri Sotnikov
  - [[http://deptinfo.unice.fr/~roy/sicp.pdf][Structure and Interpretation of Computer Programs]] --- Harold
    Abelson, Gerald Jay Sussman with Julie Sussman (sa video
    [[https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/][predavanjima]] na YouTube-u)
