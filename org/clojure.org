#+TITLE: Napredne tehnike programiranja - Clojure
#+LANGUAGE: sr
#+SETUPFILE: org-html-themes/setup/theme-bigblow.setup
#+PROPERTY: header-args:python :session osnove_programiranja :results output :exports both
#+TAGS: za_radoznale

[[file:images/clojure_logo.png]]

#+BEGIN_QUOTE
Clojure is a dynamic, general-purpose programming language, combining
the approachability and interactive development of a scripting
language with an efficient and robust infrastructure for multithreaded
programming. Clojure is a compiled language, yet remains completely
dynamic – every feature supported by Clojure is supported at
runtime. Clojure provides easy access to the Java frameworks, with
optional type hints and type inference, to ensure that calls to Java
can avoid reflection.

Clojure is a dialect of Lisp, and shares with Lisp the code-as-data
philosophy and a powerful macro system. Clojure is predominantly a
functional programming language, and features a rich set of immutable,
persistent data structures. When mutable state is needed, Clojure
offers a software transactional memory system and reactive Agent
system that ensure clean, correct, multithreaded designs.

-- Rich Hickey (author of Clojure)
#+END_QUOTE

* Uvod

  #+BEGIN_QUOTE
  If your mind is empty, it is always ready for anything, it is open to
  everything. In the beginner's mind there are many possibilities, but
  in the expert's mind there are few.

  -- Shunryu Suzuki
  #+END_QUOTE

** Lisp

   *Lisp* ili *LISP* je porodica programskih jezika sa dugom
   istorijom. Na prvi pogled ga karakteriše prefiksna notacija i
   izrazi u zagradama. Prvobitno je specificiran 1956. godine od
   strane [[https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)][John McCarthy]]-a za potrebe njegovih istraživanja u oblasti
   veštačke inteligencije (/McCarthy/ je inače i smislio naziv
   /artificial intelligence/ - /AI/). Lisp je drugi najstariji
   programski jezik visokog nivoa, samo je /Fortran/ jednu godinu
   stariji, a poređenja radi:
   - [[https://en.wikipedia.org/wiki/C_(programming_language)][C]] se pojavio 1972.
   - [[https://en.wikipedia.org/wiki/C%252B%252B][C++]] 1983.
   - [[https://en.wikipedia.org/wiki/Python_(programming_language)][Python]] 1991 (kada i [[https://en.wikipedia.org/wiki/Visual_Basic][Visual Basic]]).
   - [[https://en.wikipedia.org/wiki/Java_(programming_language)][Java]] 1995.
   - [[https://en.wikipedia.org/wiki/C_Sharp_(programming_language)][C#]] 2000.

   Lisp je konstruisan kao matematička notacija za kompjuterske
   programe inspirisana [[https://en.wikipedia.org/wiki/Lambda_calculus][Lambda računom]]([[https://en.wikipedia.org/wiki/Alonzo_Church][Alonzo Church]]). Ovaj način
   predstave programa doneo je mnoge ideje u kompjuterske nauke:
   - strukture tipa stabla
   - automatsko upravljanje memorijom (garbage collector)
   - /dynamic typing/
   - kondicionale (grananje)
   - funkcije višeg reda
   - rekurziju i rekurzivan opis podataka
   - self-hosting kompajler
   - REPL itd.

   Veliki broj navedenih stvari inspirisao je programske jezike koji
   su nastali nakon Lisp-a (tj. skoro sve programske jezike) ali neki
   od korisnih koncepata iz Lisp-a se i dan dans smatraju naprednim i
   još uvek nisu podržani u pojedinim jezicima koji se intenzivno
   koriste.

   Matematičku formulaciju Lisp-a i koncepata koje ona donosi nadalje
   pogledajte [[../resources/perzistencija_clojure.pdf][ovde]] (poglavlja 1.1, 1.2 i 1.3).

   Pored /Clojure/ dijalekta kojim ćemo se baviti na ovom kursu tu je
   još pregršt drugih dijalekata sa raznim osobinama:

   - [[https://common-lisp.net/][Commnon Lisp]]
   - [[https://en.wikipedia.org/wiki/Scheme_(programming_language)][Scheme]]
   - [[https://www.gnu.org/software/emacs/][Emacs Lisp]]
   - [[https://en.wikipedia.org/wiki/AutoLISP][AutoLisp]]
   - [[http://www.paulgraham.com/arc.html][Arc]]
   - [[http://lfe.io/][Lisp Flovered Erlang]]
     ...

*** Scheme

    *Scheme* je jedan od najznačajnijih dijalekata Lisp-a. Dizajniran
    je od početka sa idejom funkcionalnog programiranja i minimalizma
    sa veoma moćnim mehanizmima za proširenje jezika. Prvi je
    dijalekat koji usled naglašavanja funkcionalnog programiranja
    uvodi [[https://en.wikipedia.org/wiki/Tail_call][tail call optimizaciju]]. Takođe jedan je od prvih programskih
    jezika koji imaju podržanu [[https://en.wikipedia.org/wiki/Continuation][kontinuaciju]].

    Neke od "biblija" računarske nauke i programiranja generalno su
    kao jezik-primer uzimale upravo Scheme. Jedna takva knjiga je i
    [[http://deptinfo.unice.fr/~roy/sicp.pdf][Structure and Interpretation of Computer Programs]].

    Postoji mnogo raznih dijalekata Scheme-a a ovde će biti navedena
    samo dva.

**** Chez Scheme (Cisco)

     [[https://github.com/cisco/ChezScheme][*Chez*]] je [[http://www.r6rs.org/][Scheme implementacija]] zajedno sa (moćnim) kompajlerom,
     /run time/ sistemom i bibliotekama. Koristi je kompanije Cisco a
     od skoro je /open source/.

     Ako danas želite da probate Scheme da njime rešite problem na
     kome radite a fokus Vam je na performansama, IO, konkurentnom
     programiranju ili Vam treba dobra mogućnost korišćenja postojećih
     C biblioteka onda nije loše da počnete sa *Chez*-om.

**** Racket lang

     [[https://racket-lang.org/][Racket lang]] je takođe implementacija Schema-a ali sa potpuno
     drugim ciljevima pri dizajnu. Racket je po svom dizajnu sistem za
     pravljenje programskih jezika (i/ili [[https://en.wikipedia.org/wiki/Domain-specific_language][DSL]]-ova). Ima veoma dobar
     ekosistem biblioteka (u formi jezika) za razne standardne (WEB
     serveri, GUI ...) i manje standardne zadatke. Sve njegove
     biblioteke su veoma dobro dokumentovane. Racket ima i svoje
     razvojno okruženje (IDE) DrRacket koje sadrži sve na šta ste
     navikli od jednog IDE-a (uključujući i grafički debugger). Ako je
     dizajn DSL-ova način na koji razmišljate pri rešavanju problema
     onda će Racket lang i njegovo okruženje biti odlično društvo od
     kojeg možete mnogo da naučite.

** Clojure - funkcionalni način razmišljanja

   Danas postoji mnogo programskih jezika i zaista se (pre)veliki deo
   njih međusobno razlikuje skoro isključivo po sintaksi. Tako da
   danas nije nikakav problem nazivati se *polyglot* programerom -
   samo naučite par sintaktičkih pravila i /Voila!/ znate još jedan
   programski jezik (nezaboravite da osvežite svoj CV).

   *Clojure* ipak nije jedan od jezika koji su Vam od ranije
   poznati. Čak ni na prvi pogled (za šta je zaslužna /S-expression/
   prefiksna notacija). Stoga, kako biste ga naučili morate primeniti
   neku drugu strategiju u odnosu na onu navedenu iznad.

   Evo jednog predloženog pristupa:

   #+BEGIN_QUOTE
   Zaboravite sve što znate o programiranju. *Pristupite učenju
   Clojure-a kao da Vam je to prvi programski jezik* . U suprotnom
   ćete Clojure shvatiti samo kao /prefiksnu notaciju sa zagradama
   okolo koja Vam ne dozvoljava da pišete kod onako kako ste navikli!/

   *Umesto da pokušavate svoje znanje od ranije da preslikate na*
   *Clojure dozvolite ovom Lispu da obogati način na koji pišete*
   *ostale programske jezike.*
   #+END_QUOTE

** Imperativno vs funckionalno programiranje

   C, C++, C#, Java, Python svi ovi (i drugi) programski jezici imaju
   veoma sličnu sintaksu i svi koriste veoma slične programske
   konstrukcije sa akcentom na imperativno programiranje.

   #+BEGIN_QUOTE
   U kompjuterskoj nauci imperativnim programiranjem je paradigma
   programiranja koja koristi naredbe u cilju menjanja stanja
   programa.
   #+END_QUOTE

   Ova paradigma programiranja se savršeno uklapa u [[https://en.wikipedia.org/wiki/Von_Neumann_architecture][von Neumann-ov
   model izračunavanja]] na računaru. Tačnije, ona je dizajnirana kako
   bi oslikala pomenuti model izračunavanja.

   Na primer, C je dominirao softverom veliki broj godina jer se
   odlično uklapa u ovu dominantnu paradigmu hardverske
   arhitekture. Programi napisani u C-u su veoma efikasni i u stanju
   su da vrše veoma efikasno upravljanje memorijom koja je do skora
   bila veliki problem. Ova efikasnost je plaćena cenom izraženom u
   kompleksnijoj semantici i sintaksi samog jezika i sa porastom
   programskog koda dramatično opada sposobnost programera da
   iskontroliše konstruktorsku kompleksnost u takvim programima što
   dovodi do češćih defekata u radu programa (*program radi brzo ali
   ne i ono što želimo --- korektno*). Ova kompleksnost potiče od toga
   što kod imperativnog programiranja posao koji naredbe obavljaju
   snažno zavisi od stanja memorije u tom momentu. To čini
   *konkurentno* programiranje veoma komplikovanim i stoga podložnim
   greškama.

   #+BEGIN_QUOTE
   Danas kada je memorija veoma brza i jeftina a kada višeprocesorske
   arhitekture svi nosimo u džepovima ili pametnim satovima
   imperativno programiranje počinje da pokazuje ozbiljne znake
   starenja.
   #+END_QUOTE

   Funkcionalno programiranje se zasniva više na stabilnim
   matematičkim konceptima nego na bilo kom modelu izračunavanja na
   mašini. Clojure kao funkcionalan programski jezik ima snažan fokus
   na [[https://en.wikipedia.org/wiki/Immutable_object][nepromenljivosti podataka]] (u daljem tekstu mutabilnost). To mu
   omogućava veoma čiste i jednostavne apstrakcije za konkurentno
   programiranje koje su svakako korektnije i manje podložno greškama
   od eksplicitnog zaključavanja delova memorije na koje smo usmereni
   u imperativnom programiranju.

   Clojure (kao Lisp) je zapravo zasnovan na jednom veoma konciznom
   matematičkom modelu kakav je Lambda račun pa tako i njegova
   sintaksa barata sa svega nekoliko raznih konstrukcija što je čini
   veoma prostom. /Uviđanje ove jednostavnosti dolazi uz malo vežbe./

** Clojure kao /value oriented/ jezik

   Clojure promoviše stil programiranja koji se zove /value-oriented
   programming/ i nije jedini jezik koji to radi. *Rich Hickey* je
   ovaj koncept vrlo lepo objasnio u svom [[https://www.youtube.com/watch?v=-6BsiVyC1kM][izlaganju]] na /Jax
   Conf/-u 2012. godine.

   Ideja je da se programer koncentriše na vrednosti u njegovom
   programu a ne na mutabilne objekte i njihovo stanje (objekti se
   smatraju tankom apstrakcijom oko "gole" memorije). Ovo je veoma
   moćan koncept jer kada prestanete da razmišljate o objektima i
   memoriji onda konkurentno programiranje postaje manje više
   trivijalan posao

** Clojure u standardnim OO problemima

* Elementi jezika

** /Homoiconicy/ --- "istoizglednost"

   #+ATTR_HTML: :width 700
   #+CAPTION: [[https://twitter.com/franschm][@franschm]]
   [[file:images/franca_homoiconicy_clojure.jpg]]

   Primetimo da u jezicima koji nisu /homoikonični/ važi pravilo:

   *Kod je Kralj, podaci se zamišljaju.*

   Dok kod jezika koji su /homoikonični/ situacija nije tako
   striktna. Kod u koji gledamo su zapravo podaci, ne moramo da ih
   zamišljamo.

* REPL i IDE

* Read, evaluate vrtlog i makroi

* Konkurentno i paralelno programiranje

** Reference

** core.async

* Interakcija sa platformom

* Apstrakcije

** Multimethods

** Protocols

** Records

** clojure.spec

* ClojureScript

* Reader conditionals (.cljc)

* ClojureCLR

* Literatura
  - [[http://www.braveclojure.com/][Clojure For The Brave and True]] --- Daniel Higginbotham
  - Professional Clojure --- Anderson, Gaare, Holguin, Bailey, Pratley
  - Web Development with Clojure 2nd Edition --- Dmitri Sotnikov
  - [[http://deptinfo.unice.fr/~roy/sicp.pdf][Structure and Interpretation of Computer Programs]] --- Harold
    Abelson, Gerald Jay Sussman with Julie Sussman (sa video
    [[https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/][predavanjima]] na YouTube-u)
