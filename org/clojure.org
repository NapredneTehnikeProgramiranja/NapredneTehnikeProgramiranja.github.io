#+TITLE: Napredne tehnike programiranja - Clojure
#+LANGUAGE: sr
#+SETUPFILE: org-html-themes/setup/theme-bigblow.setup
#+TAGS: za_radoznale

[[file:images/clojure_logo.png]]

#+BEGIN_QUOTE
Clojure is a dynamic, general-purpose programming language, combining
the approachability and interactive development of a scripting
language with an efficient and robust infrastructure for multithreaded
programming. Clojure is a compiled language, yet remains completely
dynamic – every feature supported by Clojure is supported at
runtime. Clojure provides easy access to the Java frameworks, with
optional type hints and type inference, to ensure that calls to Java
can avoid reflection.

Clojure is a dialect of Lisp, and shares with Lisp the code-as-data
philosophy and a powerful macro system. Clojure is predominantly a
functional programming language, and features a rich set of immutable,
persistent data structures. When mutable state is needed, Clojure
offers a software transactional memory system and reactive Agent
system that ensure clean, correct, multithreaded designs.

-- Rich Hickey (author of Clojure)
#+END_QUOTE

* Uvod

  #+BEGIN_QUOTE
  If your mind is empty, it is always ready for anything, it is open to
  everything. In the beginner's mind there are many possibilities, but
  in the expert's mind there are few.

  -- Shunryu Suzuki
  #+END_QUOTE

** Lisp

   *Lisp* ili *LISP* je porodica programskih jezika sa dugom
   istorijom. Na prvi pogled ga karakteriše prefiksna notacija i
   izrazi u zagradama. Prvobitno je specificiran 1956. godine od
   strane [[https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)][John McCarthy]]-a za potrebe njegovih istraživanja u oblasti
   veštačke inteligencije (/McCarthy/ je inače i smislio naziv
   /artificial intelligence/ - /AI/). Lisp je drugi najstariji
   programski jezik visokog nivoa, samo je /Fortran/ jednu godinu
   stariji, a poređenja radi:
   - [[https://en.wikipedia.org/wiki/C_(programming_language)][C]] se pojavio 1972.
   - [[https://en.wikipedia.org/wiki/C%252B%252B][C++]] 1983.
   - [[https://en.wikipedia.org/wiki/Python_(programming_language)][Python]] 1991 (kada i [[https://en.wikipedia.org/wiki/Visual_Basic][Visual Basic]]).
   - [[https://en.wikipedia.org/wiki/Java_(programming_language)][Java]] 1995.
   - [[https://en.wikipedia.org/wiki/C_Sharp_(programming_language)][C#]] 2000.

   Lisp je konstruisan kao matematička notacija za kompjuterske
   programe inspirisana [[https://en.wikipedia.org/wiki/Lambda_calculus][Lambda računom]]([[https://en.wikipedia.org/wiki/Alonzo_Church][Alonzo Church]]). Ovaj način
   predstave programa doneo je mnoge ideje u kompjuterske nauke:
   - strukture tipa stabla
   - automatsko upravljanje memorijom (garbage collector)
   - /dynamic typing/
   - kondicionale (grananje)
   - funkcije višeg reda
   - rekurziju i rekurzivan opis podataka
   - self-hosting kompajler
   - REPL itd.

   Veliki broj navedenih stvari inspirisao je programske jezike koji
   su nastali nakon Lisp-a (tj. skoro sve programske jezike) ali neki
   od korisnih koncepata iz Lisp-a se i dan dans smatraju naprednim i
   još uvek nisu podržani u pojedinim jezicima koji se intenzivno
   koriste.

   Matematičku formulaciju Lisp-a i koncepata koje ona donosi nadalje
   pogledajte [[../resources/perzistencija_clojure.pdf][ovde]] (poglavlja 1.1, 1.2 i 1.3).

   Pored /Clojure/ dijalekta kojim ćemo se baviti na ovom kursu tu je
   još pregršt drugih dijalekata sa raznim osobinama:

   - [[https://common-lisp.net/][Commnon Lisp]]
   - [[https://en.wikipedia.org/wiki/Scheme_(programming_language)][Scheme]]
   - [[https://www.gnu.org/software/emacs/][Emacs Lisp]]
   - [[https://en.wikipedia.org/wiki/AutoLISP][AutoLisp]]
   - [[http://www.paulgraham.com/arc.html][Arc]]
   - [[http://lfe.io/][Lisp Flovered Erlang]]
     ...

*** Scheme

    *Scheme* je jedan od najznačajnijih dijalekata Lisp-a. Dizajniran
    je od početka sa idejom funkcionalnog programiranja i minimalizma
    sa veoma moćnim mehanizmima za proširenje jezika. Prvi je
    dijalekat koji usled naglašavanja funkcionalnog programiranja
    uvodi [[https://en.wikipedia.org/wiki/Tail_call][tail call optimizaciju]]. Takođe jedan je od prvih programskih
    jezika koji imaju podržanu [[https://en.wikipedia.org/wiki/Continuation][kontinuaciju]].

    Neke od "biblija" računarske nauke su kao jezik-primer uzimale
    upravo Scheme. Jedna, vrlo značajna, takva knjiga je i [[http://deptinfo.unice.fr/~roy/sicp.pdf][Structure
    and Interpretation of Computer Programs]].

    Postoji mnogo raznih dijalekata Scheme-a a ovde će biti navedena
    samo dva.

**** Chez Scheme (Cisco)

     [[https://github.com/cisco/ChezScheme][*Chez*]] je [[http://www.r6rs.org/][Scheme implementacija]] zajedno sa (moćnim) kompajlerom,
     /run time/ sistemom i bibliotekama. Koristi je kompanije Cisco a
     od skoro je /open source/.

     Ako danas želite da probate Scheme da njime rešite problem na
     kome radite a fokus Vam je na performansama, IO, konkurentnom
     programiranju ili Vam treba dobra mogućnost korišćenja postojećih
     C biblioteka onda nije loše da počnete sa *Chez*-om.

**** Racket lang

     [[https://racket-lang.org/][Racket lang]] je takođe implementacija Schema-a ali sa potpuno
     drugim ciljevima pri dizajnu. Racket je po svom dizajnu sistem za
     pravljenje programskih jezika (i/ili [[https://en.wikipedia.org/wiki/Domain-specific_language][DSL]]-ova). Ima veoma dobar
     ekosistem biblioteka (u formi jezika) za razne standardne (WEB
     serveri, GUI ...) i manje standardne zadatke. Sve njegove
     biblioteke su veoma dobro dokumentovane. Racket ima i svoje
     razvojno okruženje (/IDE/) DrRacket koje sadrži sve na šta ste
     navikli od jednog /IDE/-a (uključujući i grafički
     /debugger/). Ako je dizajn DSL-ova način na koji razmišljate pri
     rešavanju problema onda će Racket lang i njegovo okruženje biti
     odlično društvo od kojeg možete mnogo da naučite.

** Clojure - funkcionalni način razmišljanja

   Danas postoji mnogo programskih jezika i zaista se (pre)veliki deo
   njih međusobno razlikuje skoro isključivo po sintaksi. Tako da
   danas nije nikakav problem nazivati se *polyglot* programerom -
   samo naučite par sintaktičkih pravila i /Voila!/ znate još jedan
   programski jezik (nezaboravite da osvežite svoj CV).

   *Clojure* ipak nije jedan od jezika koji se početniku čini od
   ranije poznatim. Čak ni na prvi pogled (za šta je zaslužna
   /S-expression/ prefiksna notacija). Stoga, kako biste ga naučili
   morate primeniti neku drugu strategiju u odnosu na onu navedenu
   iznad.

   Evo jednog predloženog pristupa:

   #+BEGIN_QUOTE
   Zaboravite sve što znate o programiranju. *Pristupite učenju
   Clojure-a kao da Vam je to prvi programski jezik* . U suprotnom
   ćete Clojure shvatiti samo kao /prefiksnu notaciju sa zagradama
   koja Vam ne dozvoljava da pišete kod onako kako ste navikli!/

   *Umesto da pokušavate svoje znanje od ranije da preslikate na*
   *Clojure, dozvolite ovom Lispu da obogati način na koji pišete*
   *ostale programske jezike.*
   #+END_QUOTE

** Imperativno vs funckionalno programiranje

   C, C++, C#, Java, Python svi ovi (i drugi) programski jezici imaju
   veoma sličnu sintaksu i svi koriste veoma slične programske
   konstrukcije sa akcentom na imperativno programiranje.

   #+BEGIN_QUOTE
   U kompjuterskoj nauci imperativno programiranje je paradigma
   programiranja koja koristi naredbe u cilju menjanja stanja
   programa.
   #+END_QUOTE

   Ova paradigma programiranja se savršeno uklapa u [[https://en.wikipedia.org/wiki/Von_Neumann_architecture][von Neumann-ov]]
   model izračunavanja na računaru. Tačnije, ona je dizajnirana kako
   bi oslikala pomenuti model izračunavanja.

   Na primer, C je dominirao softverom veliki broj godina jer se
   odlično uklapa u ovu dominantnu paradigmu hardverske
   arhitekture. Programi napisani u C-u su veoma efikasni i u stanju
   su da vrše veoma efikasno upravljanje memorijom koja je /do skora/
   bila veliki problem. Ova efikasnost je plaćena cenom izraženom u
   kompleksnijoj semantici i sintaksi samog jezika pa sa porastom
   programskog koda dramatično opada sposobnost programera da
   iskontroliše konstruktorsku kompleksnost što dovodi do češćih
   defekata u radu programa (*program radi brzo ali ne i ono što
   želimo --- korektno*). Ova kompleksnost potiče od toga što kod
   imperativnog programiranja posao koji naredbe obavljaju snažno
   zavisi od stanja memorije u tom momentu. To čini *konkurentno*
   programiranje veoma komplikovanim i stoga podložnim greškama.

   #+BEGIN_QUOTE
   Danas kada je memorija veoma brza i jeftina a kada višeprocesorske
   arhitekture svi nosimo u džepovima ili pametnim satovima
   imperativno programiranje počinje da pokazuje ozbiljne znake
   starenja.
   #+END_QUOTE

   Funkcionalno programiranje se zasniva više na stabilnim
   matematičkim konceptima nego na bilo kom modelu izračunavanja na
   mašini. Clojure kao funkcionalan programski jezik ima snažan fokus
   na [[https://en.wikipedia.org/wiki/Immutable_object][nepromenljivosti podataka]] (u daljem tekstu imutabilnost). To mu
   omogućava veoma čiste i jednostavne apstrakcije za konkurentno
   programiranje koje su svakako korektnije i manje podložno greškama
   od eksplicitnog zaključavanja delova memorije na koje smo usmereni
   u imperativnom programiranju.

   Clojure (kao Lisp) je zapravo zasnovan na jednom veoma konciznom
   matematičkom modelu kakav je Lambda račun pa tako i njegova
   sintaksa barata sa svega nekoliko raznih konstrukcija što je čini
   veoma prostom. /Uviđanje ove jednostavnosti dolazi uz malo vežbe./

** Clojure kao /value oriented/ jezik

   Clojure promoviše stil programiranja koji se zove /value-oriented
   programming/ i nije jedini jezik koji to radi. *Rich Hickey* je
   ovaj koncept vrlo lepo objasnio u svom [[https://www.youtube.com/watch?v=-6BsiVyC1kM][izlaganju]] na /Jax
   Conf/-u 2012. godine.

   Ideja je da se programer koncentriše na vrednosti u njegovom
   programu a ne na mutabilne objekte i njihovo stanje (objekti se
   smatraju tankom apstrakcijom oko "gole" memorije). Ovo je veoma
   moćan koncept jer kada prestanete da razmišljate o objektima i
   memoriji onda konkurentno programiranje postaje manje-više
   trivijalan posao.

   U objektno orijentisanom programiranju takođe imamo potrebu i za
   skrivanjem informacija (/information hiding/) i ograničavanjem
   pristupa delovima objekta kroz /enkapsulaciju/. Clojure otklanja tu
   potrebu jer barata samim vrednostima, podaci su *semantički
   transparentni*. Ovaj nivo transparentnosti omogućava bolju osnovu
   za rezonovanje o kodu. Uprošćavanje kompleksnih funkcija *uvek*
   može biti izvedeno prostom supstitucijom. Evo jednog naivnog
   primera koji to ilustruje:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" src clojure :lines "15-22"

** Referencijalna transparentnost i memoizacija

   Funkcije za koje uvek po njihovim parametrima možete da kažete sa
   čim bi ste ih zamenili su [[https://en.wikipedia.org/wiki/Referential_transparency][referencijalno transparentne]]. Da li su
   funkcije koje pišete u matematici referencijalno transparentne? Da
   li je $x^2$ uvek isto za isto $x$?

   *Ako je kvadrat broja 4323 uvek 18688329 da li ga ima smisla uvek
   iznova računati?*

   Optimizaciona tehnika koja nam omogućuje da programski jezik
   zapamti vrednosti referencijalno transparentnih funkcija za
   parametre zove se [[https://en.wikipedia.org/wiki/Memoization][memoizacija]].

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" :src clojure :lines "23-57"

   Kada se memoizovana funkcija poziva prvi put ona troši vreme kao i
   njena obična verzija ali se svaki sledeći put kada bude pozvana
   *uštedi jedno vreme izvršavanja*.

** Misliti rekurzivno

   Iz razloga koji su opisani [[*Imperativno vs funckionalno programiranje][ranije]] imperativni programski jezici ne
   stavljaju previše akcenat na rekurziju. Funcionalno programiranje
   rekurziju koristi kao osnovni alat. Tamo gde imperativno
   programiranje koristi petlje funkcionalno programiranje koristi
   razne vidove rekurzije.

   #+BEGIN_QUOTE
   Rekurzija je kada rešenje problem opisujete rešavanjem manje
   porcije tog istog problema.

   Rekurzija je jedna od centralnih ideja kompjuterske nauke.
   #+END_QUOTE

   [[file:images/First_matryoshka_museum_doll_open.jpg]]

   [[file:images/RecursiveTree.jpg]]

   Imperativno programiranje problem faktorijela posmatra ovako:

   #+BEGIN_SRC python
     def factorial(n):
         acc = 1

         for i in range(1, n + 1):
             acc *= i

         return acc
   #+END_SRC

   Clojure kao funkcionalan [[*Clojure kao /value oriented/ jezik][value oriented]] jezik ne podržava mutiranje
   pa tako:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" :src clojure :lines "58-62"

   Ako ispratimo izvršavanje ove rekurzije videćemo da "clojure" mora
   svaku operaciju da stavi na stek kako =n= raste. To za veliko =n=
   može izazvati /stack overflow/:

   #+BEGIN_SRC clojure
     (factorial 6)
     (* 6 (factorial 5))
     (* 6 (* 5 (factorial 4)))
     (* 6 (* 5 (* 4 (factorial 3))))
     (* 6 (* 5 (* 4 (* 3 (factorial 2)))))
     (* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
     (* 6 (* 5 (* 4 (* 3 (* 2 1)))))
     (* 6 (* 5 (* 4 (* 3 2))))
     (* 6 (* 5 (* 4 6)))
     (* 6 (* 5 24))
     (* 6 120)
     720
   #+END_SRC

   Ovakva rekurzija se naziva još i *linearna rekurzija*.

   U opštem slučaju ovaj problem se rešava [[https://en.wikipedia.org/wiki/Tail_call][tail call optimizacijom]].

   Međutim, pošto je Clojure *hosted* programski jezik, a /JVM/ ne
   podržava ovu optimizaciju onda se Clojure koristi jednim trikom ---
   =recur=

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" :src clojure :lines "63-75"

   Naš =factorial= koristeći =recur= možemo napisati na sledeći način:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" :src clojure :lines "76-81"

   =loop= konstrukcija je zapravo anonimna - /lambda/ funkcija sa
   početnim /binding/-om.

   #+BEGIN_QUOTE
   /Binding/ u kompjuterskoj nauci znači asocijaciju nekog imena i nekog izraza.
   #+END_QUOTE

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" :src clojure :lines "82-94"

   Primetite da *sada imamo poziv recur kao poslednji izraz u
   funkciji* (u repu - /tail call/) pa tako nema potrebe za čuvanjem
   na steku. Funkcija se izvršava ovako:

   #+BEGIN_SRC clojure
     (factorial-recur 6)
     (loop 6 1)
     (loop 5 6)
     (loop 4 30)
     (loop 3 120)
     (loop 2 360)
     (loop 1 720)
     (loop 0 720)
     720
   #+END_SRC

   Šta ako imamo potrebu za međusobnom rekurzijom (pogledajte zadatak
   sa parsiranjem iz Python dela ovog kursa)?

   Za potrebe ilustracije ovog koncepta implementirajmo svoju funckiju
   za određivanje da li je broj paran ili ne na sledeći način:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" :src clojure :lines "95-120"

   Međutim, ovaj pristup opet ima problem sa alokacijom steka. Pa
   definišimo to na malo drugačiji način:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" :src clojure :lines "121-140"

   Međutim, korisnik naše funkcije sada mora da zna da treba da je
   pozove sa =trampoline=. To nije baš divno. Pa preformulišimo to još
   malo:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" :src clojure :lines "141-172"

   Sada je već bolje. A najbolje je što sada *nema nepotrebnih
   alokacija steka*.

* REPL i IDE

** /Build tools/ - alati za izgradnju
   U Clojure zajednici se paralelno koriste dva alata za izgradnju:

   - [[https://leiningen.org/][Leiningen]]
   - [[http://boot-clj.com/][Boot]]

   /Lein/ je po svom funkcionisanju sličniji alatima za razvoj koje
   srećemo u drugim programskim jezicima pa ćemo ga na ovom kursu
   koristiti. Ovde je potrebno napomenuti da je /Boot/ prilično
   zanimljiv i inovativan pristup izgradnji i da mu svakako vredi
   posvetiti pažnju. /Boot/ na veoma pametan način koristi Clojure kao
   potpuno dinamičko Lisp okruženje.

   Kako biste počeli da koristite /lein/ potrebno je da pročitate
   /[[https://github.com/technomancy/leiningen/blob/stable/doc/TUTORIAL.md#creating-a-project][Creating a Project]]/ poglavlje iz totorijala.

** /IDE/ - integrisana razvojna okruženja
   Podešavanje za rad u Clojure-u nije teško pronaći bez obzira na to
   koji je Vaš omiljeni način rada i sviđaju li Vam se više
   tradicionalni editori ili tradicionalna razvojna okruženja. Evo par
   rešenja:

   - GNU/Emacs - [[https://github.com/clojure-emacs/cider][CIDER]] ([[http://blog.cognitect.com/blog/2017/1/31/state-of-clojure-2016-results][najkorišćenije]] u okviru Clojure zajednice)
   - Vim - [[https://github.com/tpope/vim-fireplace][Fireplace]]
   - Eclipse - [[http://doc.ccw-ide.org/documentation.html][Counterclockwise]]
   - IntelliJ - [[https://cursive-ide.com/][Cursive]]
   - [[http://lighttable.com/][LightTable]] - napredni editor pisan u Clojure-u (podržava osnovne
     Clojure alate bez dodatne konfiguracije)
   - [[https://sekao.net/nightcode/][Nightcode]] - osnovni editor pisan u Clojure-u (preporučen Clojure
     početnicima)

* Elementi jezika
  Ovaj kurs nema deo posvećen upoznavanju sa bazičnim elementima
  jezika iz par razloga:

  1. jer bi autor ovog teksta to sigurno uradio lošije nego što je urađeno:
     - u knjizi /Clojure For The Brave And True/ [[http://www.braveclojure.com/do-things/][ovde]].
     - na sajtu [[https://kimh.github.io/clojure-by-example/#require][Clojure By Example]].
  2. jer su bazični elementi jezika vrlo unificirani (kao i kod svakog
     Lisp-a).
  3. jer se proste stvari najbrže uče individualno (tada je najmanja
     šansa da Vam neko proste stvari zakomplikuje svojim lošim
     objašnjenjem)

** Funkcije višeg reda
   [[https://en.wikipedia.org/wiki/Higher-order_function][Funkcije višeg]] reda su funkcije koje primaju funkcije kao parametre
   i/ili vraćaju funkcije.

   Neke funkcije višeg reda kao što su =map=, =filter=, =reduce= su
   Vam poznate od ranije iz drugih programskih jezika.

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/higher_order_functions.clj" src clojure :lines "4-15"

   Sećate li se objektnog programiranja i [[https://en.wikipedia.org/wiki/Command_pattern][Command pattern]]-a iz Jave?

   #+BEGIN_SRC java
     // Command is an interface defining method execute() for its execution

     public void wrapInTransaction(Command c) throws Exception {
         setupDataInfrastructure();
         try {
             c.execute();
             completeTransaction();
         } catch (Exception condition) {
             rollbackTransaction();
             throw condition;
         } finally {
             cleanUp();
         }
     }

     public void addOrderFrom(final ShoppingCart cart, final String userName,
                              final Order order) throws Exception {
         wrapInTransaction(new Command() {
                 public void execute() {
                     add(order, userKeyBassedOn(username));
                     addLineItemsFrom(cart, order.getOrderKey());
                 }
             });
     }
   #+END_SRC

   Nije li funkcija odličan način za modelovanje neke funkcije
   (komande) sistema? :)

   Verovatno jeste. Problem objektnog programiranja u Javi je što ako
   posao modelujemo funkcijom onda posao ne možemo poslati nekoj
   metodi na izvršavanje jer nemamo na raspolaganju funkcije višeg
   reda. U Clojure-u je to prirodna stvar:

   #+BEGIN_SRC clojure
     (defn wrapInTransaction [f]
       (do
         (startTransaction)
         (f)
         (completeTransaction)))

     (wrapInTransaction #(do
                           (add order user)
                           (addLineItemsFrom cart orderKey)))
   #+END_SRC

   Ruku na srce, Java od verzije 1.8 ima podršku za funkcije višeg
   reda. Najbolji način da uvidite koliko su funkcije višeg reda
   prirodne za Clojure je da ih probate u npr. Javi.

*** Parcijalne funkcije
    Kada smo radili napredno Python programiranje videli smo šta su i
    kako se mogu koristiti parcijalne funkcije. Pogledajmo u ovom
    odeljku za šta se one mogu koristiti.

    U objektnom programiranju postoji način da izgradimo neki objekat
    u nizu koraka. Pošto objektno programiranje prethodno ustanovljene
    prakse zove šablonima onda se šablon o kome ovde govorimo zove
    [[https://en.wikipedia.org/wiki/Builder_pattern][/Builder Pattern/]]. Takođe postoji i jedan prilično sličan šablon
    koji služi da za proizvodnju sličnih objekata - [[https://en.wikipedia.org/wiki/Abstract_factory_pattern][/Abstract Factory
    Pattern/]].

    Sa druge strane, osnovni metod apstrakcije funkcionalnih
    programskih jezika su funkcije, a koncept koji nam omogućuje da od
    postojećih funkcija sa već datim delom parametara pravimo nove
    funkcije su *parcijalne funkcije*.

    Pogledajmo sada osnovno korišćenje parcijalnih funkcija u
    Cljure-u:

    #+INCLUDE: "clojure-ntp/src/clojure_ntp/partials.clj" src clojure :lines "6-20"

    Sada možemo dati neke primere Clojure-a iz realnog sveta koji
    pokazuju kako se mogu koristiti parcijalne funkcije tamo gde se u
    objektnom programiranju koriste gorepomenuti šabloni:

    Za ovaj primer nam je potrebna biblioteka [[https://github.com/clojure/java.jdbc][=clojure.java.jdbc=]].

    I recimo da želimo da pravimo upite na našu bazu podataka koristeći
    samo =clojure.java.jdbc=. To u praksi možemo uradi ovako:

    #+INCLUDE: "clojure-ntp/src/clojure_ntp/partials.clj" src clojure :lines "21-47"

    U objektnom programiranju ne biste pisali specifikaciju konekcije
    na bazu u svakom upitu već biste se već nekako odlučili da pravite
    /builder/ (razmisliti šta to sve tačno obuhvata). Ovde biste
    takav efekat postigli mnogo direktnije:

    #+INCLUDE: "clojure-ntp/src/clojure_ntp/partials.clj" src clojure :lines "48-66"

    Naravno, kao i svim široko korišćenim programskim jezicima i u
    Clojure-u postoji čitav spektar gotovih biblioteka koje Vam daju
    apstrakciju nad osnovnim drajverom baze podataka (u ovom slučaju
    nad /jdbc/-om).

    Drugi primer iz /real world/ Clojure koda gde se koriste parcijalne
    funkcije je kada imate funkciju višeg reda kojoj želite da
    prosledite neku funkciju koja prima više parametara. Npr. funkcija
    =*= nema previše smisla za jedan argument.

    #+INCLUDE: "clojure-ntp/src/clojure_ntp/partials.clj" src clojure :lines "67-72"

    Prokomentarišite sledeći rezultat?

    #+INCLUDE: "clojure-ntp/src/clojure_ntp/partials.clj" src clojure :lines "73-78"

    Nedostatak parcijalnih funkcija formulisanih na način kako je to
    urađeno u Clojure-u što se parametri funkcije parcijalizuju *samo*
    sa početka. Na primer funkciju =-= ne možemo *samo* koristeći
    =partial= parcijalizovati drugim parametrom već samo prvim.

    #+INCLUDE: "clojure-ntp/src/clojure_ntp/partials.clj" src clojure :lines "79-81"

    Ali možemo postići taj efekat uvodeći jednu prostu =lambdu=:

    #+INCLUDE: "clojure-ntp/src/clojure_ntp/partials.clj" src clojure :lines "82-84"

** Kompozicija funkcija
   Još jednom, Clojure svoje korene vuče iz matematike pa tako ima još
   jedan veoma moćan koncept apstrakcije - *kompoziciju funkcija*.

   #+BEGIN_QUOTE
   Kompozicija funkcija je primena funkcije na rezultate druge
   funkcije u cilju dobijanja treće funkcije.

   $f \circ g (x) = f(g(x))$
   #+END_QUOTE

   Ili za one kojima je poznavanje /Unix-a/ trenutno ispred poznavanja
   matematike - "to je ako pipe (|) u /shell-u/":

   #+BEGIN_SRC shell
     ls | grep "clojure-ntp"
   #+END_SRC

   U svrhu ilustracije zamislimo da imamo neki JavaScript kod i da
   želimo da ga minificiramo tj. da pročitamo JavaScript fajl kao
   tekst i da iz tog teksta izbacimo sve nove redove i druge
   nepotrebne karaktere kako bi se manje podataka prenosilo mrežom. Za
   to vrlo elegantno možemo da iskoristimo kompoziciju funkcija koje
   već postoje u Clojure-u:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/partials.clj" src clojure :lines "85-92"

   Primetimo da se poslednja navedena funkcija poziva prva tj. primena
   funkcija ide "iznutra ka spolja". To možda može izgledati čudno
   (iako je baš tako i u matematičkoj notaciji) pa onda Clojure pruža
   drugi način da se ovo zapiše korišćenjem /threading macro/-a (o
   makroima će biti reči [[*Read, evaluate vrtlog i makroi][u nastavku]]):

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/partials.clj" src clojure :lines "93-100"

** Clojure naglašava svoju lenjost
   Clojure se ne smatra lenjim jezikom u smislu u kome se to misli
   kada se govori o Haskell-u (o tome u nastavku kursa) ali naglašava
   lenje izvršavanje na mnogim mestima.

   Mnoge ugrađene funkcije vraćaju lenje sekvence. Takve su =map=,
   =reduce=, =filter= i druge. To se može jednostavno videti na
   primeru:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/partials.clj" src clojure :lines "101-110"

   Da Clojure nije lenj tačke bi se ispisivale na ekran odmah pri
   definisanju =result=-a. Ovako je ispisivanje na ekran pozvano tek
   kada smo zatražili da se =result= isprinta.

   Još jedna stvar za koju lenje sekvence mogu biti od koristi je i
   predstava beskonačnih struktura. Npr, ako imamo lenje sekvence i
   skup realnih brojeva onda fibonačijevu sekvencu možemo da
   predstavimo na sledeći način:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/partials.clj" src clojure :lines "111-139"

   Kada smo radili napredni Python upoznali smo se sa metodama koje
   nam omogućuju da beskonačno kružimo kroz konačne strukture. Ovde je
   dat još jedan primer korišćenja ovog koncepta:

   Recimo želimo da ravnomerno rasporedimo ljude iz kolekcije na 4
   moguća izlaza:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/partials.clj" src clojure :lines "140-181"

** Vežbanje 1
   Ideje zadataka uglavnom preuzete sa [[https://www.4clojure.com][4Clojure]].

   1. Napisati funkciju =say-hello= koja prima parametar =name= i vraća
      tekst =Hello to <name>=.
   2. Napisati funkciju =get-the-caps= koja prima string engleskih
      slova a vraća samo njegova velika slova.

      #+INCLUDE: "clojure-ntp/src/clojure_ntp/exercises_1.clj" src clojure :lines "7-38"

   3. Napisati funkciju =drop-nth= koja prima dva parametra od kojih je
      prvo vektor elemenata a drugo =n=. Funkcija vraća listu bez
      svakog =n=-tog elementa.

      Eksplicitnom rekurzijom:

      #+INCLUDE: "clojure-ntp/src/clojure_ntp/exercises_1.clj" src clojure :lines "39-84"

      Ili koristeći =keep-indexed= funkciju:

      #+INCLUDE: "clojure-ntp/src/clojure_ntp/exercises_1.clj" src clojure :lines "85-136"

      Ili uz malo skupovnih operacija:

      #+INCLUDE: "clojure-ntp/src/clojure_ntp/exercises_1.clj" src clojure :lines "137-159"

   4. Napravite =flip= funkciju višeg reda koja invertuje parametre
      prosleđene funkcije.

      #+BEGIN_SRC clojure
        ((flip -) 1 2)
        ;; => 1
      #+END_SRC

      #+INCLUDE: "clojure-ntp/src/clojure_ntp/exercises_1.clj" src clojure :lines "160-185"

   5. Napisati funkciju =b-tree?= koja proverava da li je neka
      sekvenca binarno stablo.

      #+BEGIN_SRC clojure
        (b-tree? [1 [2 [3 [4 false nil] nil] nil] nil])
        ;; => true

        (b-tree? '(:a nil ()))
        ;; => false

        (b-tree? [1 [2 nil nil] [3 nil nil] [4 nil nil]])
        ;; => false

        (b-tree? '(:a (:b nil nil) nil))
        ;; => true
      #+END_SRC

      #+INCLUDE: "clojure-ntp/src/clojure_ntp/exercises_1.clj" src clojure :lines "186-206"

   6. Lepota je u simetriji. Napišite predikat =beauty-tree?= koji
      proverava da li je binarno stablo simetrično. Stablo je
      simetrično ako je svako levo podstablo odraz u ogledalu od
      desnog podstabla.

** Kada je mutacija stvarno nezaobilazna
   To što je Clojure /value oriented/ ne znači da ne postoji način da
   koristite mutabilna stanja već da kada ih koristite ona moraju biti
   dobro izolovana i jedino na pravilan (konzistentan) način možete
   njima rukovati. Clojure pruža nekoliko mehanizama za rukovanje
   mutabilnim stanjem.

*** Atom
    /Atomi/ su prvi i najjednostavniji mehanizam za rukovanje
    mutabilnim stanjem. Ideja je da se oni uposle kada imamo
    *sinhrono*, *nekoordinisano* ili *nezavisano* korišćenje deljenih
    resursa. Dakle, ako treba da baratamo samo jednim parčetom
    mutabilnog stanja od jednom i drugih zahteva onda su Atomi prava
    stvar za nas (i upravo to je i najčešće).

    Do sada smo uvek kada govorimo o Clojure-u govorili o vrednostima
    (a ne o promenljivom sadržaju), /atomi su definisani na malo
    složeniji način/. Pošto nam treba da atomima predstavimo nešto što
    se može menjati u vremenu i pošto Clojure ne dozvoljava mutabilne
    strukture podataka jedini način da se implementiraju atomi je bio
    --- _kao promenljive reference na imutabilne strukture_. Jedan
    način kako se definiše atom je dat u nastavku:

    #+INCLUDE: "clojure-ntp/src/clojure_ntp/atoms.clj" src clojure :lines "3-6"

    Ovako smo napravili atom koji sadrži praznu perzistentnu -
    *imutabilnu* mapu a čija je referenca sačuvana u =app-state=
    (adresa mape je data heksadecimalno). Pošto ovako prazna naša mapa
    nije baš korisna hajde da asociramo neke vrednosti unutar nje:

    #+INCLUDE: "clojure-ntp/src/clojure_ntp/atoms.clj" src clojure :lines "8-24"

    Dakle, funkcija =swap!= *zamenjuje* vrednost na kuju pokazuje
    =app-state= za neku drugu vrednost koja je rezultat primene
    funkcije =assoc= na onu vrednost na koju trenutno pokazuje
    =app-state= i ostale argumente. Naravno, umesto =assoc= funkcije
    se može koristiti bilo koja druga.

    Ako samo želimo da *zamenimo* vrednost na koju trenutno pokazuje
    =app-state= sa nekom drugom vrednošću za to možemo koristiti
    funkciju =reset!=:

    #+INCLUDE: "clojure-ntp/src/clojure_ntp/atoms.clj" src clojure :lines "25-27"

    Sada kada znamo kako da sačuvamo deljeno stanje u okviru atoma
    pitanje je --- kako da ga pročitamo odatle? Operacija čitanja se u
    ovom kontekstu zove *dereferenciranje* i radi se funkcijom =deref=
    ili =@= /reader macro/-om:

    #+INCLUDE: "clojure-ntp/src/clojure_ntp/atoms.clj" src clojure :lines "28-37"

    Ovaj vrlo prost i intuitivan mehanizam nas spašava pisanje
    eksplicitnih zaključavanja i daje nam veoma čist - funkcionalni
    API za rukovanje deljenim stanjem.

    Prokomentarišite rezultate ispod.

    #+INCLUDE: "clojure-ntp/src/clojure_ntp/atoms.clj" src clojure :lines "63-116"

*** Ref
    Atomi nam daju mehanizam za rukovanje mutabilnim deljenim stanjem
    kada je to stanje predstavljeno jednom vrednošću. Kada je stanje
    predstavljeno kroz *više vrednosti* i kada rukovanje stanjem
    zahteva *koordinaciju* između njih tu su Refs. Klasičan primer
    koji se navodi kada se govori o ovoj vrsti deljenog stanje je
    prenos sredstava između računa u banci. Refs u Clojure-u uvek
    funkcionišu kroz sistem za postizanje konkurentnosti koji se
    koristi kod baza podataka --- transakcijama. Mehanizam koji
    obezbeđuje da se transakcije obavljaju na nivou programa se naziva
    [[https://en.wikipedia.org/wiki/Software_transactional_memory][Software transactional memory]](STM) i ispunjava prva 3 načela [[https://en.wikipedia.org/wiki/ACID][ACID]]
    principa (Atomicity, Consistency, Isolation). Četvrti (Durability)
    naravno nije ispunjen po dizajnu jer je sve definisano na nivou
    programa.

    Ovaj, kao i verovatno većina kurseva koja se bave ovom temom u
    svrhu ilustracije daće primer sa prenosom sredstava među računima
    u banci ali ćemo za početak da zašto to ne možemo da
    implementiramo koristeći Atome:

    #+INCLUDE: "clojure-ntp/src/clojure_ntp/atoms.clj" src clojure :lines "117-149"

    Dakle, atomi nas ne čuvaju od toga da akcija nad jednim uspe a nad
    drugim ne uspe --- _nekoordinisani su_. I zato su to Refs:

    #+INCLUDE: "clojure-ntp/src/clojure_ntp/atoms.clj" src clojure :lines "150-215"

** Perzistentne strukture podataka
   Kako bismo lakše razumeli efikasnost imutabinih/perzistentnih
   struktura podataka u Clojure-u ovde ćemo pukašati da opišemo šta se
   tu ispod haube zapravo dešava i šta se to tačno _kopira_ kada
   Clojure "vraća vrednosti koje su nastale od prethodnih vrednosti".

   Strukture podataka većine imperativnih programskih jezika koje ste
   do sada koristili su uglavnom destruktivne prirode --- kada nešto
   želite da izmenite to se bukvalno izmeni na mestu na kome se
   nalazi. Ne možete više tu strukturu da prosleđujete unaokolo po svom
   programu bez bojazni da će se neko računanje koje koristi tu
   strukturu podataka "pokvariti".

   Na primer, ako izmenite drugi element neke liste /L1/ u programskom
   jeziku kao što je Java, sadržaj na tom mestu u memoriji je
   promenjen i to više nije ona stara lista, stare _više nema_ i sva
   računanja koja koriste ovu listu moraju to da prepoznaju i pravilno
   reaguju.

   #+ATTR_HTML: :width 700
   #+CAPTION: slika iz knjige [[http://www.wrox.com/WileyCDA/WroxTitle/Professional-Clojure.productCd-1119267277.html][Professional Clojure]]
   [[file:images/Selection_001.png]]

   Clojure sa druge strane svoje strukture podataka implementira u
   perzistentnom maniru, to znači da svaki put kada pokušate da
   izmenite vrednost zapravo _dobijete novu vrednost koja može da deli
   neki deo strukture sa originalnom_. Možda deljenje strukture na
   prvi pogled može izgledati rizično ali pošto su svi delovi neke
   vrednosti (npr. kolekcije) same po sebi imutabilne tu nema nikakvih
   problema.

   Pogledajmo sada isti primer "izmene" nekog elementa liste kod
   Clojure-a. Ono što se zapravo događa je vraćanje _nove liste_ /L2/
   koja je nastala kopiranjem svih elemenata originalne liste do onog
   koji želimo da menjamo, a ostatak strukture deli sa originalnom.

   #+ATTR_HTML: :width 700
   #+CAPTION: slika iz knjige [[http://www.wrox.com/WileyCDA/WroxTitle/Professional-Clojure.productCd-1119267277.html][Professional Clojure]]
   [[file:images/Selection_002.png]]

   Da smo želeli da dodamo listu /L2/ na kraj liste /L1/ desilo bi se
   kopiranje liste /L1/ sa tim što bi pokazivač na poslednjem elementu
   nove liste /L2/ pokazivao na početak liste /L3/.

   #+ATTR_HTML: :width 700
   #+CAPTION: slika iz knjige [[http://www.wrox.com/WileyCDA/WroxTitle/Professional-Clojure.productCd-1119267277.html][Professional Clojure]]
   [[file:images/Selection_003.png]]

   _Imajte u vidu_ da je osnovna motivacija za ovakvu implementaciju
   bila _očuvanje itegriteta_ podataka i zaštita korektnosti
   izračunavanja, a _ne puke performanse_ koje mogu narušiti
   korektnost. Na ovom konkretnom primeru to znači da sva računanja
   koja koriste /L1/ mogu da nastave _kao da se ništa nije desilo_ ---
   ušteda na vremenu i prostoru se očekuje ovde.

   Kako bismo stekli bolji osećaj o funkcionisanju perzistentnih
   struktura podataka pogledajmo kako bismo implementirali binarno
   stablo:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/persistent_datastructures.clj" src clojure :lines "0-35"

   Pogledajmo sada kako bismo pravili stablo:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/persistent_datastructures.clj" src clojure :lines "36-47"

   Super! Hajde sada da napravimo neko malo zanimljivije stablo:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/persistent_datastructures.clj" src clojure :lines "48-50"

   Kod od gore bi trebao da odgovara stablu ispod:

   #+ATTR_HTML: :width 700
   #+CAPTION: slika iz knjige [[http://www.wrox.com/WileyCDA/WroxTitle/Professional-Clojure.productCd-1119267277.html][Professional Clojure]]
   [[file:images/Selection_004.png]]

   Pa hajde da to validiramo:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/persistent_datastructures.clj" src clojure :lines "51-69"

   Hajde sada da ispitamo identite levih i desnih podstabala našeg stabla:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/persistent_datastructures.clj" src clojure :lines "70-85"

   Ono na šta treba da obratimo pažnju su konkretne adrese na kojima
   se nalaze identiteti naših čvorova koji predstavljaju levo i desno
   podstablo.

   Hajde sada da da dodamo jedan čvor sa vrednošću 6 u stablo
   (naravno, nema mutiranja, dobijamo potpuno novo stablo):

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/persistent_datastructures.clj" src clojure :lines "86-87"

   *Šta je ovde sad kopirano a šta se deli?*

   Ispitajmo leva i desna podstabla našeg novog stabla:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/persistent_datastructures.clj" src clojure :lines "88-99"

   Levo podstablo nam nije poznato (po adresi, po identitetu) ali
   desno jeste...

   _to je taj isti identitet koji ujedno predstavlja i desno podstablo
   početnog stabla_!

   Dakle, ono što smo zapravo napravili je struktura kao na slici ispod:

   #+ATTR_HTML: :width 700
   #+CAPTION: slika iz knjige [[http://www.wrox.com/WileyCDA/WroxTitle/Professional-Clojure.productCd-1119267277.html][Professional Clojure]]
   [[file:images/Selection_005.png]]

   Dakle, *desilo se neko kopiranje* ali je *neki deo strukture
   deljen* i nije se kopirao. Oni koji žele da znaju koji se tačno deo
   kopira a koji se deli kao i kako se to računa mogu svoje čitanje da
   nastave na nekom od sledećih mesta:
   - blog [[http://hypirion.com/musings/understanding-persistent-vector-pt-1][Polymatheia]]
   - Higher Order Blog ([[http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation][ovde]] i [[http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice][ovde]])

   Ovaj kurs ne pokriva dublju priču na ovu temu ali Vam je toplo
   preporučuje. :)

** Clojure u standardnim OO problemima
* Read, evaluate vrtlog i makroi

  #+BEGIN_QUOTE
  Sve navedeno u ovom poglavlju važi za Clojure kako i za sve ostale
  Lisp jezike i obrnuto, osim ako drugačije nije naznačeno.
  #+END_QUOTE

  Programski jezici koji spadaju u porodicu Lisp jezika imaju korisnu
  i zanimljivu osobinu da mogu veoma elegantno da transformišu _bilo
  kakve izraze_ u validan kod. Šta to praktično znači:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/macros.clj" src clojure :lines "3-13"

   Sve gore navedeno radi fino iako sledeći izrazi uopšte nisu
   sintaktički validni u Clojure-u:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/macros.clj" src clojure :lines "14-21"

   Ova osobina nam omogućuje da jednostavno _menjamo jezik_ u kome
   programiramo shodno problemu koji rešavamo našim programom. To na
   kraju dovodi do momenta kada svoj program možemo da pišemo
   _direktno preslikavajući_ svoje znanje iz domena problema na
   kod. Tako dobijamo maksimalnu ekspresivnost (deklerativnost) koda i
   minimalan prostor za greške u domenu problema koji rešavamo.

   Filozofija koja stoji iza makroa je sledeća:

   #+BEGIN_QUOTE
   Ako pravite WEB aplikaciju --- programirajte jezikom WEB-a (a ne
   jezikom opšte namene).

   Ako pravite grafički interfejs --- programirajte jezikom grafičkih
   interfejsa (a ne jezikom opšte namene).

   Ako programirate sistem za genetska istraživanja --- programirajte
   jezikom genetike (a ne jezikom opšte namene).

   ...
   #+END_QUOTE

   Ono što Vam Cljure pruža u duhu ove filozofije je veoma moćan a
   lagan sistem u kome možete da pišete Vaše nove jezike. Taj sistem
   čak _nije nadgradnja_ Lisp-a već je u _osnovi njegove
   konstrukcije_, u temeljima --- u /evaluation model/-u.

** /Evaluation Model/ Clojure-a
   Lisp ima model izvršavanja koji se u osnovi razlikuje od ostalih
   programskih jezika. Taj sistem radi u dve faze --- čita se kod kao
   tekst i od njega se pravi Lisp struktura podataka. Te strukture
   podataka se potom evaluiraju(izračunavaju): obilazi se struktura i
   rade se razne akcije nad njom na osnovu tipa izraza.

   Npr. kada Lisp čita tekst =(+ 1 2)= u prvoj fazi se dobija Lisp
   lista čiji je prvi element =+= a potom idu brojevi 1 i 2. Ta Lista
   se onda šalje evaluatoru koji potraži funkciju koja odgovara
   simbolu =+= i primeni je na brojeve 1 i 2.

   Jezici koji imaju ovakvu vezu između koda, podataka i izvršavanja
   se nazivaju *homoikoničnim*.

   #+BEGIN_QUOTE
   Homoikonični jezici Vam daju moć da na kod gledate kao na strukturu
   podataka koja se može programski menjati.
   #+END_QUOTE

   Kako bismo objasnili način nakoji je ovo izvedeno hajde da
   napravimo jedan mali osvrt na kompajlere i proces kompaanja:
   Programski kod je samo skup karaktera a kompjuter razume samo
   mašinske instrukcije. Dakle, da bi mašina mogla da izvršava kod
   potreban nam je interpreter ili kompajler. Tokom svog rada
   kompajler konstruiše stablo apstrakne sintakse (AST) --- strukturu
   podataka koja predstavlja program. AST se potom prosledi evaluatoru
   na izvršavanje. Evaluator možete zamisliti kao funkciju koja
   obilazi stablo i pravi mašinske instrukcije za čvorove kroz koje
   prolazi.

   Dakle, proces kompajliranja poprilično podseća na ono što radi
   Lisp. Međutim, kod većine programskih jezika AST nije dostupno u
   programskom jeziku. Prostor u kome deluje kompajler i prostor u
   koje deluje sam programski jezik su razdvojeni. Proces
   kompajliranja izvršavanja u ne-Lisp jezicima možete zamisliti na
   sledeći način:

   #+ATTR_HTML: :width 500
   #+CAPTION: Ilustracija iz knjige [[http://www.braveclojure.com/read-and-eval/][Clojure For The Brave And True]]
   [[file:images/Selection_006.png]]

   Za razliku od većine programskih jezika Lisp svoje apstraktno
   sintaksno stablo predstavlja u obliku svojih struktura podataka ---
   ugnježdenih listi. Evo jedne ilustracije koja pokazuje da su Lisp
   izrazi zapravo već sami posebi jedan način predstave stabla:

   #+ATTR_HTML: :width 500
   #+CAPTION: Ilustracija iz knjige [[http://www.braveclojure.com/read-and-eval/][Clojure For The Brave And True]]
   [[file:images/Selection_007.png]]

   Dakle, Clojure /reader/ dobije na ulaz tekst a na izlazu da AST u
   obliku Clojure listi koje kasnije prosledi evaluatoru. Proces
   izvršavanja Lisp-a možete zamisliti na sledeći način:

   #+ATTR_HTML: :width 500
   #+CAPTION: Ilustracija iz knjige [[http://www.braveclojure.com/read-and-eval/][Clojure For The Brave And True]]
   [[file:images/Selection_008.png]]

   Dakle, *Lisp kod je zapravo Lisp struktura podataka*. Da bismo
   pokazali da je to stvarno tako evo primera koji pokazuje da su
   /evaluator/ i /reader/ _dostupni u svakom vašem programu_:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/macros.clj" src clojure :lines "22-31"

   Pošto je Clojure homoikoničan zašto bismo pisali stringove? Hajde
   da pišemo *liste == kod*:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/macros.clj" src clojure :lines "32-39"

   Ali liste su podrazumevane strukture podataka u Lispu a evaluator
   se poziva implicitno :) Pa je tako sve ovo prosto ekvivalentno sa:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/macros.clj" src clojure :lines "40-50"

   Sada kada nam je potpuno jasno kako Lisp radi hajde da pokušamo da
   razumemo šta se tačno dešava sa makroom na početku:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/macros.clj" src clojure :lines "3-13"

   Da bismo ovo razumeli potrebno nam je da još detaljnije pogledamo
   kako izgleda proces izvršavanja Lisp-a. Zato hajde napišemo još
   jedan mali makro:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/macros.clj" src clojure :lines "69-77"

   I pogledajmo kako teče izvršavanje ovog malog programa:

   #+ATTR_HTML: :width 200
   #+CAPTION: Ilustracija iz knjige [[http://www.braveclojure.com/read-and-eval/][Clojure For The Brave And True]]
   [[file:images/Selection_009.png]]

   Dakle, Lisp kod u obliku teksta se izvršava tako što se prvo
   pročita *reader*-om onda se razviju svi makroi *makroexpander*-om i
   rezultujuća struktura podataka se preda *evaluator*-u.

   Kako bismo utvrdili da je jasno šta se dešava pogledajmo još jedan
   makro:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/macros.clj" src clojure :lines "78-94"

** Neki poznati /reader/ makroi
   Znamo da anonimnu funkciju u Clojure možemo da napišemo na više
   načina i da je jedan od njih =#(...)=, drugi =(fn [...] ...)=. Kako
   to radi?

   *Kao /reader/ makro*:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/macros.clj" src clojure :lines "53-55"

   Dakle, struktura podataka koja izađe iz /reader/-a kada koristimo
   jedan način i kada koristimo drugi način je zapravo jedno te isto.

   Na sličan način je napravljeno citiranje sintakse u Clojure:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/macros.clj" src clojure :lines "54-56"

   Takođe i dereferenciranje:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/macros.clj" src clojure :lines "57-59"

   I komentari su izvedeni na taj način:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/macros.clj" src clojure :lines "60-62"

** /Homoiconicity/ --- "istoizglednost"
   Razmotrite ovaj crtež i primetite kako fleksibilnost /evaluation
   model/-a Lispa utiče na dizajn programa koji su pisani u
   njemu. /Homoikoničnost/ jezika čini implementaciju čitavog niza
   alata konceptualno trivijalnim (mackroi, validacija podataka i
   generativno testiranje --- [[*clojure.spec][Clojure.spec]], transfer podataka --- [[https://github.com/edn-format/edn][EDN]],
   konfiguracija...).

   #+ATTR_HTML: :width 700
   #+CAPTION: [[https://twitter.com/franschm][@franschm]]
   [[file:images/franca_homoiconicy_clojure.jpg]]

   Primetimo da u jezicima koji nisu /homoikonični/ važi pravilo:

   *Kod je Kralj, podaci se zamišljaju.*

   Dok kod jezika koji su /homoikonični/ situacija nije tako
   striktna. Kod u koji gledamo su zapravo podaci, ne moramo da ih
   zamišljamo.

** Reader conditionals (.cljc)

* Konkurentno i paralelno programiranje

** Reference

** core.async

* Interakcija sa platformom
* Apstrakcije

** Multimethods

** Protocols

** Records

** clojure.spec
   Clojure je dinamički programski jezik i kao takvom mu nisu
   neophodne anotacije tipova u vreme kompajliranja. Iako Clojure ima
   /type hints/ oni nisu ni obavezni a ni dovoljno bogat mehanizam već
   samo služe da pomognu kompajleru kako bi rezultujući kod bio što
   efikasniji. Ipak, u Clojure zajednici je uvek bila praksa da se
   koriste različite biblioteke za opis oblika podataka i predikatskih
   pravila koja se proveravaju u vreme izvršavanja. Komentari, koji su
   osnovni mehanizam u dinamičkim programskim jezicima, mogu da
   posluže za komunikaciju sa čovekom ali u automatskoj proveri ili
   testiranju i ne baš.

   Početnicima u Clojure svetu poruke o grešci koje potiču iz ručnog
   parsiranja podataka ili restruktuiranja čestu deluju nejasno
   (posebno kada one dođu od makroa). U ovom slučaju deklerativni opis
   podataka može mnogo da pomogne u razumevanju greške.

   Ako govorimo o testiranju onda je /property based testing/ tehnika
   koja nam omogućuje mnogo pouzdanije testove od onih koje bismo
   napisali ručno. Kako bi se testovi mogli generisati (npr. pomoću
   [[https://github.com/clojure/test.check][test.check]]) potreban je dobar opis podataka a to je upravo posao
   [[https://clojure.org/about/spec][clojure.spec]]-a.

   Pored svih svoji osobina /clojure.spec/ _nije_ /type system/ ---
   /type/ sistemi uzimaju za korektno samo ono što je formalno
   dokazivo, /clojure.spec/ dozvoljava veću ekspresivnost u opisu ali
   sa druge strane ne teži nikakvom formalnom dokazu
   korektnosti. Takođe ono čime se /clojure.spec/ bavi jesu dinamički
   stvoreni podaci u programu a ne statički.

   #+BEGIN_QUOTE
   Dakle, smisao =clojure.spec=-a je da pruži moćan mehanizam za
   deklerativan opis podataka koji će se proveravati u vreme
   izvršavanja.
   #+END_QUOTE

   U ovom delu ćemo dati neke primere korićenja a za opširniji uvod
   pogledajte [[https://clojure.org/guides/spec][ovde]].

   *[napomena]* /clojure.spec/ je uveden u Clojure verziji =1.9= koja
   još nije oficijalno izašla pa će tako primeri biti dati za verziju
   =1.9.0-alpha16=.

   Šemu možemo definisati na sledeći način:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/spec.clj" src clojure :lines "1-12"

   A ovako možemo proveriti da li je neki podatak validan po nekoj šemi:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/spec.clj" src clojure :lines "13-17"

   Dajemo još primera:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/spec.clj" src clojure :lines "21-35"

   Ako želimo da kažemo da neka vrednost treba da zadovoljava šemu ili
   da bude =nil=:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/spec.clj" src clojure :lines "36-42"

   Postoji i funkcija koja može da "objasni" zašto neki podaci ne
   zadovoljavaju datu šemu:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/spec.clj" src clojure :lines "43-50"

*** Validatori za mape
    Validitori za mape se kreiraju sa =clojure.spec/keys=:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/spec.clj" src clojure :lines "51-84"

   Evo nekih primera:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/spec.clj" src clojure :lines "85-135"

*** Validatori za kolekcije
    Validatore za kolekcije možete dobiti i korišćenjem sledećih /helper/-a:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/spec.clj" src clojure :lines "136-197"

*** Validatori za sekvence
    Sekvencijalni podaci se mogu validirati validatorima koji
    oslikavaju one standardne operatore kod regularnih izraza:

    - =cat= --- konkatenacija šema
    - =alt= --- izbor šema
    - =*= --- 0 ili više pojava neke šeme
    - =+= --- 1 ili više pojava neke šeme
    - =?= --- 0 ili 1 pojava neke šeme

    Ovde ćemo dati samo neke primere:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/spec.clj" src clojure :lines "198-210"

*** Validiranje funkcija
    Pošto možemo opisati podatke onda možemo opisati i parametre
    funkcije kao i njene povratne vrednosti. Dodatno, možemo opisati i
    funkciju koja će proveriti da li važi neka za:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/spec.clj" src clojure :lines "211-323"

*** Generativno testiranje =test-check=
    Kada imamo sve ove validatore baš bi bilo dobro da postoji način
    da generišemo podatke iz šeme. To bi nam baš bilo korisno za
    testiranje. Ono što nam treba za ovako nešto se nalazi u
    =clojure.spec.gen.alpha= /namespace-u/.

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/spec.clj" src clojure :lines "324-365"

   Funkcija kojom možemo da dobijemo uporedno generisane podatke i
   njihovo slaganje u šemu je =exercise=:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/spec.clj" src clojure :lines "366-373"

   Možemo od generatora dobiti i parove ulaz-izlaz za funkcije kojima
   smo dali šeme i koje smo instrumentalizovali --- eto generativnog
   testiranja:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/spec.clj" src clojure :lines "374-396"

* ClojureScript

* Literatura
  - [[http://www.braveclojure.com/][Clojure For The Brave and True]] --- Daniel Higginbotham
  - Professional Clojure --- Anderson, Gaare, Holguin, Bailey, Pratley
  - Web Development with Clojure 2nd Edition --- Dmitri Sotnikov
  - [[http://deptinfo.unice.fr/~roy/sicp.pdf][Structure and Interpretation of Computer Programs]] --- Harold
    Abelson, Gerald Jay Sussman with Julie Sussman (sa video
    [[https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/][predavanjima]] na YouTube-u)
