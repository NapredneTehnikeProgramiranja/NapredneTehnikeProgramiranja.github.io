#+TITLE: Napredne tehnike programiranja - Clojure
#+LANGUAGE: sr
#+SETUPFILE: org-html-themes/setup/theme-bigblow.setup
#+TAGS: za_radoznale

[[file:images/clojure_logo.png]]

#+BEGIN_QUOTE
Clojure is a dynamic, general-purpose programming language, combining
the approachability and interactive development of a scripting
language with an efficient and robust infrastructure for multithreaded
programming. Clojure is a compiled language, yet remains completely
dynamic – every feature supported by Clojure is supported at
runtime. Clojure provides easy access to the Java frameworks, with
optional type hints and type inference, to ensure that calls to Java
can avoid reflection.

Clojure is a dialect of Lisp, and shares with Lisp the code-as-data
philosophy and a powerful macro system. Clojure is predominantly a
functional programming language, and features a rich set of immutable,
persistent data structures. When mutable state is needed, Clojure
offers a software transactional memory system and reactive Agent
system that ensure clean, correct, multithreaded designs.

-- Rich Hickey (author of Clojure)
#+END_QUOTE

* Uvod

  #+BEGIN_QUOTE
  If your mind is empty, it is always ready for anything, it is open to
  everything. In the beginner's mind there are many possibilities, but
  in the expert's mind there are few.

  -- Shunryu Suzuki
  #+END_QUOTE

** Lisp

   *Lisp* ili *LISP* je porodica programskih jezika sa dugom
   istorijom. Na prvi pogled ga karakteriše prefiksna notacija i
   izrazi u zagradama. Prvobitno je specificiran 1956. godine od
   strane [[https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)][John McCarthy]]-a za potrebe njegovih istraživanja u oblasti
   veštačke inteligencije (/McCarthy/ je inače i smislio naziv
   /artificial intelligence/ - /AI/). Lisp je drugi najstariji
   programski jezik visokog nivoa, samo je /Fortran/ jednu godinu
   stariji, a poređenja radi:
   - [[https://en.wikipedia.org/wiki/C_(programming_language)][C]] se pojavio 1972.
   - [[https://en.wikipedia.org/wiki/C%252B%252B][C++]] 1983.
   - [[https://en.wikipedia.org/wiki/Python_(programming_language)][Python]] 1991 (kada i [[https://en.wikipedia.org/wiki/Visual_Basic][Visual Basic]]).
   - [[https://en.wikipedia.org/wiki/Java_(programming_language)][Java]] 1995.
   - [[https://en.wikipedia.org/wiki/C_Sharp_(programming_language)][C#]] 2000.

   Lisp je konstruisan kao matematička notacija za kompjuterske
   programe inspirisana [[https://en.wikipedia.org/wiki/Lambda_calculus][Lambda računom]]([[https://en.wikipedia.org/wiki/Alonzo_Church][Alonzo Church]]). Ovaj način
   predstave programa doneo je mnoge ideje u kompjuterske nauke:
   - strukture tipa stabla
   - automatsko upravljanje memorijom (garbage collector)
   - /dynamic typing/
   - kondicionale (grananje)
   - funkcije višeg reda
   - rekurziju i rekurzivan opis podataka
   - self-hosting kompajler
   - REPL itd.

   Veliki broj navedenih stvari inspirisao je programske jezike koji
   su nastali nakon Lisp-a (tj. skoro sve programske jezike) ali neki
   od korisnih koncepata iz Lisp-a se i dan dans smatraju naprednim i
   još uvek nisu podržani u pojedinim jezicima koji se intenzivno
   koriste.

   Matematičku formulaciju Lisp-a i koncepata koje ona donosi nadalje
   pogledajte [[../resources/perzistencija_clojure.pdf][ovde]] (poglavlja 1.1, 1.2 i 1.3).

   Pored /Clojure/ dijalekta kojim ćemo se baviti na ovom kursu tu je
   još pregršt drugih dijalekata sa raznim osobinama:

   - [[https://common-lisp.net/][Commnon Lisp]]
   - [[https://en.wikipedia.org/wiki/Scheme_(programming_language)][Scheme]]
   - [[https://www.gnu.org/software/emacs/][Emacs Lisp]]
   - [[https://en.wikipedia.org/wiki/AutoLISP][AutoLisp]]
   - [[http://www.paulgraham.com/arc.html][Arc]]
   - [[http://lfe.io/][Lisp Flovered Erlang]]
     ...

*** Scheme

    *Scheme* je jedan od najznačajnijih dijalekata Lisp-a. Dizajniran
    je od početka sa idejom funkcionalnog programiranja i minimalizma
    sa veoma moćnim mehanizmima za proširenje jezika. Prvi je
    dijalekat koji usled naglašavanja funkcionalnog programiranja
    uvodi [[https://en.wikipedia.org/wiki/Tail_call][tail call optimizaciju]]. Takođe jedan je od prvih programskih
    jezika koji imaju podržanu [[https://en.wikipedia.org/wiki/Continuation][kontinuaciju]].

    Neke od "biblija" računarske nauke su kao jezik-primer uzimale
    upravo Scheme. Jedna, vrlo značajna, takva knjiga je i [[http://deptinfo.unice.fr/~roy/sicp.pdf][Structure
    and Interpretation of Computer Programs]].

    Postoji mnogo raznih dijalekata Scheme-a a ovde će biti navedena
    samo dva.

**** Chez Scheme (Cisco)

     [[https://github.com/cisco/ChezScheme][*Chez*]] je [[http://www.r6rs.org/][Scheme implementacija]] zajedno sa (moćnim) kompajlerom,
     /run time/ sistemom i bibliotekama. Koristi je kompanije Cisco a
     od skoro je /open source/.

     Ako danas želite da probate Scheme da njime rešite problem na
     kome radite a fokus Vam je na performansama, IO, konkurentnom
     programiranju ili Vam treba dobra mogućnost korišćenja postojećih
     C biblioteka onda nije loše da počnete sa *Chez*-om.

**** Racket lang

     [[https://racket-lang.org/][Racket lang]] je takođe implementacija Schema-a ali sa potpuno
     drugim ciljevima pri dizajnu. Racket je po svom dizajnu sistem za
     pravljenje programskih jezika (i/ili [[https://en.wikipedia.org/wiki/Domain-specific_language][DSL]]-ova). Ima veoma dobar
     ekosistem biblioteka (u formi jezika) za razne standardne (WEB
     serveri, GUI ...) i manje standardne zadatke. Sve njegove
     biblioteke su veoma dobro dokumentovane. Racket ima i svoje
     razvojno okruženje (/IDE/) DrRacket koje sadrži sve na šta ste
     navikli od jednog /IDE/-a (uključujući i grafički
     /debugger/). Ako je dizajn DSL-ova način na koji razmišljate pri
     rešavanju problema onda će Racket lang i njegovo okruženje biti
     odlično društvo od kojeg možete mnogo da naučite.

** Clojure - funkcionalni način razmišljanja

   Danas postoji mnogo programskih jezika i zaista se (pre)veliki deo
   njih međusobno razlikuje skoro isključivo po sintaksi. Tako da
   danas nije nikakav problem nazivati se *polyglot* programerom -
   samo naučite par sintaktičkih pravila i /Voila!/ znate još jedan
   programski jezik (nezaboravite da osvežite svoj CV).

   *Clojure* ipak nije jedan od jezika koji se početniku čini od
   ranije poznatim. Čak ni na prvi pogled (za šta je zaslužna
   /S-expression/ prefiksna notacija). Stoga, kako biste ga naučili
   morate primeniti neku drugu strategiju u odnosu na onu navedenu
   iznad.

   Evo jednog predloženog pristupa:

   #+BEGIN_QUOTE
   Zaboravite sve što znate o programiranju. *Pristupite učenju
   Clojure-a kao da Vam je to prvi programski jezik* . U suprotnom
   ćete Clojure shvatiti samo kao /prefiksnu notaciju sa zagradama
   koja Vam ne dozvoljava da pišete kod onako kako ste navikli!/

   *Umesto da pokušavate svoje znanje od ranije da preslikate na*
   *Clojure, dozvolite ovom Lispu da obogati način na koji pišete*
   *ostale programske jezike.*
   #+END_QUOTE

** Imperativno vs funckionalno programiranje

   C, C++, C#, Java, Python svi ovi (i drugi) programski jezici imaju
   veoma sličnu sintaksu i svi koriste veoma slične programske
   konstrukcije sa akcentom na imperativno programiranje.

   #+BEGIN_QUOTE
   U kompjuterskoj nauci imperativno programiranje je paradigma
   programiranja koja koristi naredbe u cilju menjanja stanja
   programa.
   #+END_QUOTE

   Ova paradigma programiranja se savršeno uklapa u [[https://en.wikipedia.org/wiki/Von_Neumann_architecture][von Neumann-ov]]
   model izračunavanja na računaru. Tačnije, ona je dizajnirana kako
   bi oslikala pomenuti model izračunavanja.

   Na primer, C je dominirao softverom veliki broj godina jer se
   odlično uklapa u ovu dominantnu paradigmu hardverske
   arhitekture. Programi napisani u C-u su veoma efikasni i u stanju
   su da vrše veoma efikasno upravljanje memorijom koja je /do skora/
   bila veliki problem. Ova efikasnost je plaćena cenom izraženom u
   kompleksnijoj semantici i sintaksi samog jezika pa sa porastom
   programskog koda dramatično opada sposobnost programera da
   iskontroliše konstruktorsku kompleksnost što dovodi do češćih
   defekata u radu programa (*program radi brzo ali ne i ono što
   želimo --- korektno*). Ova kompleksnost potiče od toga što kod
   imperativnog programiranja posao koji naredbe obavljaju snažno
   zavisi od stanja memorije u tom momentu. To čini *konkurentno*
   programiranje veoma komplikovanim i stoga podložnim greškama.

   #+BEGIN_QUOTE
   Danas kada je memorija veoma brza i jeftina a kada višeprocesorske
   arhitekture svi nosimo u džepovima ili pametnim satovima
   imperativno programiranje počinje da pokazuje ozbiljne znake
   starenja.
   #+END_QUOTE

   Funkcionalno programiranje se zasniva više na stabilnim
   matematičkim konceptima nego na bilo kom modelu izračunavanja na
   mašini. Clojure kao funkcionalan programski jezik ima snažan fokus
   na [[https://en.wikipedia.org/wiki/Immutable_object][nepromenljivosti podataka]] (u daljem tekstu imutabilnost). To mu
   omogućava veoma čiste i jednostavne apstrakcije za konkurentno
   programiranje koje su svakako korektnije i manje podložno greškama
   od eksplicitnog zaključavanja delova memorije na koje smo usmereni
   u imperativnom programiranju.

   Clojure (kao Lisp) je zapravo zasnovan na jednom veoma konciznom
   matematičkom modelu kakav je Lambda račun pa tako i njegova
   sintaksa barata sa svega nekoliko raznih konstrukcija što je čini
   veoma prostom. /Uviđanje ove jednostavnosti dolazi uz malo vežbe./

** Clojure kao /value oriented/ jezik

   Clojure promoviše stil programiranja koji se zove /value-oriented
   programming/ i nije jedini jezik koji to radi. *Rich Hickey* je
   ovaj koncept vrlo lepo objasnio u svom [[https://www.youtube.com/watch?v=-6BsiVyC1kM][izlaganju]] na /Jax
   Conf/-u 2012. godine.

   Ideja je da se programer koncentriše na vrednosti u njegovom
   programu a ne na mutabilne objekte i njihovo stanje (objekti se
   smatraju tankom apstrakcijom oko "gole" memorije). Ovo je veoma
   moćan koncept jer kada prestanete da razmišljate o objektima i
   memoriji onda konkurentno programiranje postaje manje-više
   trivijalan posao.

   U objektno orijentisanom programiranju takođe imamo potrebu i za
   skrivanjem informacija (/information hiding/) i ograničavanjem
   pristupa delovima objekta kroz /enkapsulaciju/. Clojure otklanja tu
   potrebu jer barata samim vrednostima, podaci su *semantički
   transparentni*. Ovaj nivo transparentnosti omogućava bolju osnovu
   za rezonovanje o kodu. Uprošćavanje kompleksnih funkcija *uvek*
   može biti izvedeno prostom supstitucijom. Evo jednog naivnog
   primera koji to ilustruje:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" src clojure :lines "15-22"

** Referencijalna transparentnost i memoizacija

   Funkcije za koje uvek po njihovim parametrima možete da kažete sa
   čim bi ste ih zamenili su [[https://en.wikipedia.org/wiki/Referential_transparency][referencijalno transparentne]]. Da li su
   funkcije koje pišete u matematici referencijalno transparentne? Da
   li je $x^2$ uvek isto za isto $x$?

   *Ako je kvadrat broja 4323 uvek 18688329 da li ga ima smisla uvek
   iznova računati?*

   Optimizaciona tehnika koja nam omogućuje da programski jezik
   zapamti vrednosti referencijalno transparentnih funkcija za
   parametre zove se [[https://en.wikipedia.org/wiki/Memoization][memoizacija]].

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" :src clojure :lines "23-57"

   Kada se memoizovana funkcija poziva prvi put ona troši vreme kao i
   njena obična verzija ali se svaki sledeći put kada bude pozvana
   *uštedi jedno vreme izvršavanja*.

** Misliti rekurzivno

   Iz razloga koji su opisani [[*Imperativno vs funckionalno programiranje][ranije]] imperativni programski jezici ne
   stavljaju previše akcenat na rekurziju. Funcionalno programiranje
   rekurziju koristi kao osnovni alat. Tamo gde imperativno
   programiranje koristi petlje funkcionalno programiranje koristi
   razne vidove rekurzije.

   #+BEGIN_QUOTE
   Rekurzija je kada rešenje problem opisujete rešavanjem manje
   porcije tog istog problema.

   Rekurzija je jedna od centralnih ideja kompjuterske nauke.
   #+END_QUOTE

   [[file:images/First_matryoshka_museum_doll_open.jpg]]

   [[file:images/RecursiveTree.jpg]]

   Imperativno programiranje problem faktorijela posmatra ovako:

   #+BEGIN_SRC python
     def factorial(n):
         acc = 1

         for i in range(1, n + 1):
             acc *= i

         return acc
   #+END_SRC

   Clojure kao funkcionalan [[*Clojure kao /value oriented/ jezik][value oriented]] jezik ne podržava mutiranje
   pa tako:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" :src clojure :lines "58-62"

   Ako ispratimo izvršavanje ove rekurzije videćemo da "clojure" mora
   svaku operaciju da stavi na stek kako =n= raste. To za veliko =n=
   može izazvati /stack overflow/:

   #+BEGIN_SRC clojure
     (factorial 6)
     (* 6 (factorial 5))
     (* 6 (* 5 (factorial 4)))
     (* 6 (* 5 (* 4 (factorial 3))))
     (* 6 (* 5 (* 4 (* 3 (factorial 2)))))
     (* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
     (* 6 (* 5 (* 4 (* 3 (* 2 1)))))
     (* 6 (* 5 (* 4 (* 3 2))))
     (* 6 (* 5 (* 4 6)))
     (* 6 (* 5 24))
     (* 6 120)
     720
   #+END_SRC

   Ovakva rekurzija se naziva još i *linearna rekurzija*.

   U opštem slučaju ovaj problem se rešava [[https://en.wikipedia.org/wiki/Tail_call][tail call optimizacijom]].

   Međutim, pošto je Clojure *hosted* programski jezik, a /JVM/ ne
   podržava ovu optimizaciju onda se Clojure koristi jednim trikom ---
   =recur=

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" :src clojure :lines "63-75"

   Naš =factorial= koristeći =recur= možemo napisati na sledeći način:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" :src clojure :lines "76-81"

   =loop= konstrukcija je zapravo anonimna - /lambda/ funkcija sa
   početnim /binding/-om.

   #+BEGIN_QUOTE
   /Binding/ u kompjuterskoj nauci znači asocijaciju nekog imena i nekog izraza.
   #+END_QUOTE

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" :src clojure :lines "82-94"

   Primetite da *sada imamo poziv recur kao poslednji izraz u
   funkciji* (u repu - /tail call/) pa tako nema potrebe za čuvanjem
   na steku. Funkcija se izvršava ovako:

   #+BEGIN_SRC clojure
     (factorial-recur 6)
     (loop 6 1)
     (loop 5 6)
     (loop 4 30)
     (loop 3 120)
     (loop 2 360)
     (loop 1 720)
     (loop 0 720)
     720
   #+END_SRC

   Šta ako imamo potrebu za međusobnom rekurzijom (pogledajte zadatak
   sa parsiranjem iz Python dela ovog kursa)?

   Za potrebe ilustracije ovog koncepta implementirajmo svoju funckiju
   za određivanje da li je broj paran ili ne na sledeći način:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" :src clojure :lines "95-120"

   Međutim, ovaj pristup opet ima problem sa alokacijom steka. Pa
   definišimo to na malo drugačiji način:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" :src clojure :lines "121-140"

   Međutim, korisnik naše funkcije sada mora da zna da treba da je
   pozove sa =trampoline=. To nije baš divno. Pa preformulišimo to još
   malo:

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/core.clj" :src clojure :lines "141-172"

   Sada je već bolje. A najbolje je što sada *nema nepotrebnih
   alokacija steka*.

* REPL i IDE
* Elementi jezika
  Ovaj kurs nema deo posvećen upoznavanju sa bazičnim elementima
  jezika iz par razloga:

  1. jer bi autor ovog teksta to sigurno uradio lošije nego što je urađeno:
     - u knjizi /Clojure For The Brave And True/ [[http://www.braveclojure.com/do-things/][ovde]].
     - na sajtu [[https://kimh.github.io/clojure-by-example/#require][Clojure By Example]].
  2. jer su bazični elementi jezika vrlo unificirani (kao i kod svakog
     Lisp-a).
  3. jer se proste stvari najbrže uče individualno (tada je najmanja
     šansa da Vam neko proste stvari zakomplikuje svojim lošim
     objašnjenjem)

** Vežbanje 1
  Ideje zadataka uglavnom preuzete sa [[https://www.4clojure.com][4Clojure]].

  1. Napisati funkciju =say-hello= koja prima parametar =name= i vraća
     tekst =Hello to <name>=.
  2. Napisati funkciju =get-the-caps= koja prima string engleskih
     slova a vraća samo njegova velika slova.
  3. Napisati funkciju =drop-nth= koja prima dva parametra od kojih je
     prvo vektor elemenata a drugo =n=. Funkcija vraća listu bez
     svakog =n=-tog elementa.

** Funkcije višeg reda
   [[https://en.wikipedia.org/wiki/Higher-order_function][Funkcije višeg]] reda su funkcije koje primaju funkcije kao parametre
   i/ili vraćaju funkcije.

   Neke funkcije višeg reda kao što su =map=, =filter=, =reduce= su
   Vam poznate od ranije iz drugih programskih jezika.

   #+INCLUDE: "clojure-ntp/src/clojure_ntp/higher_order_functions.clj" src clojure :lines "4-15"

   Sećate li se objektnog programiranja i [[https://en.wikipedia.org/wiki/Command_pattern][Command pattern]]-a iz Jave?

   #+BEGIN_SRC java
     // Command is an interface defining method execute() for its execution

     public void wrapInTransaction(Command c) throws Exception {
         setupDataInfrastructure();
         try {
             c.execute();
             completeTransaction();
         } catch (Exception condition) {
             rollbackTransaction();
             throw condition;
         } finally {
             cleanUp();
         }
     }

     public void addOrderFrom(final ShoppingCart cart, final String userName,
                              final Order order) throws Exception {
         wrapInTransaction(new Command() {
                 public void execute() {
                     add(order, userKeyBassedOn(username));
                     addLineItemsFrom(cart, order.getOrderKey());
                 }
             });
     }
   #+END_SRC

   Nije li funkcija odličan način za modelovanje neke funkcije
   (komande) sistema? :)

   Verovatno jeste. Problem objektnog programiranja u Javi je što ako
   posao modelujemo funkcijom onda posao ne možemo poslati nekoj
   metodi na izvršavanje jer nemamo na raspolaganju funkcije višeg
   reda. U Clojure-u je to prirodna stvar:

   #+BEGIN_SRC clojure
     (defn wrapInTransaction [f]
       (do
         (startTransaction)
         (f)
         (completeTransaction)))

     (wrapInTransaction #(do
                           (add order user)
                           (addLineItemsFrom cart orderKey)))
   #+END_SRC

   Ruku na srce, Java od verzije 1.8 ima podršku za funkcije višeg
   reda. Najbolji način da uvidite koliko su funkcije višeg reda
   prirodne za Clojure je da ih probate u npr. Javi.

*** Parcijalne funkcije
** Clojure u standardnim OO problemima
** Perzistentne strukture podataka

* Read, evaluate vrtlog i makroi
** /Homoiconicy/ --- "istoizglednost"

   #+ATTR_HTML: :width 700
   #+CAPTION: [[https://twitter.com/franschm][@franschm]]
   [[file:images/franca_homoiconicy_clojure.jpg]]

   Primetimo da u jezicima koji nisu /homoikonični/ važi pravilo:

   *Kod je Kralj, podaci se zamišljaju.*

   Dok kod jezika koji su /homoikonični/ situacija nije tako
   striktna. Kod u koji gledamo su zapravo podaci, ne moramo da ih
   zamišljamo.

* Konkurentno i paralelno programiranje

** Reference

** core.async

* Interakcija sa platformom

* Apstrakcije

** Multimethods

** Protocols

** Records

** clojure.spec

* ClojureScript

* Reader conditionals (.cljc)

* ClojureCLR

* Literatura
  - [[http://www.braveclojure.com/][Clojure For The Brave and True]] --- Daniel Higginbotham
  - Professional Clojure --- Anderson, Gaare, Holguin, Bailey, Pratley
  - Web Development with Clojure 2nd Edition --- Dmitri Sotnikov
  - [[http://deptinfo.unice.fr/~roy/sicp.pdf][Structure and Interpretation of Computer Programs]] --- Harold
    Abelson, Gerald Jay Sussman with Julie Sussman (sa video
    [[https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/][predavanjima]] na YouTube-u)
