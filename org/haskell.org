#+TITLE: Napredne tehnike programiranja - Haskell
#+LANGUAGE: sr
#+SETUPFILE: org-html-themes/setup/theme-bigblow.setup
#+PROPERTY: header-args:python :session osnove_programiranja :results output :exports both
#+TAGS: za_radoznale

#+ATTR_HTML: :width 400px
[[file:images/haskell_logo.png]]

#+BEGIN_QUOTE
An advanced, purely functional, statically typed, lazy programming
language.
#+END_QUOTE

* Uvod
** Elementi jezika
*** Pragme
    {-# LANGUAGE #-} {-# OPTIONS_GHC #-} {-# INCLUDE #-} {-# INFIX #-}
    {-# DEPRECATED #-} {-# WARNING #-} {-# RULES #-}
** Kompajler (GHC)
*** /Type inference/
    Haskell je implicitno tipiziran jezik (/implicitly-typed/) za
    razliku od C/C++, Java, C#, Go i dr. koji su eksplicitno
    tipizirani (explicitly-typed).
*** Sugestije kompajlera
** GHCi
** IDE
*** Hoogle
*** Stack & Stackage
** Ograničenja GHC kompajlera                                  :za_radoznale:
*** Monomorfizam restrikcija
    https://wiki.haskell.org/Monomorphism_restriction
* Funkcije
* Tipovi
** =nešto :: tip=, sve ima tip
** Kinds
   https://jeltsch.wordpress.com/2013/02/09/some-interesting-features-of-haskells-type-system/

* Data deklaracije
** Data konstruktor & value konstruktor
*** Records sintaksa
** =newtype=
** =type=

* Haskell --- lazy by default
** /Strict evaluation vs. lazy evaluation/

*** Cena /strict/ izračunavanja

*** Cena /lazy/ izračunavanja

** Haskell /laziness look and feel/ vs. Java /Supliers/ ("/type level laziness/")
   Java je na [[https://www.sitepoint.com/java-in-praise-of-laziness/][SitePoint-u]]. Haskell je na [[http://www.seas.upenn.edu/~cis194/spring13/lectures/06-laziness.html][CIS-u]].

* Polimorfizam
* GADTs
* Type Classes

** Automatsko instanciranje sa =deriving=

** =class= NIJE =class= iz Pythona i Jave

   Ono što je =type class= u Haskell-u to je sličnije abstraktnim
   klasama u Javi i Pythonu.

   #+CAPTION: haskellNTP/showcase/src/Hierarchies.hs
   #+INCLUDE: "haskellNTP/showcase/src/Hierarchies.hs" src haskell :lines "3-75"

** /fundeps/ (Functional Dependencies)
   [[https://wiki.haskell.org/Functional_dependencies][/Fundeps/]] se koriste da daju dodatna međusobna ograničenja
   parametara klasa. U klasama sa više parametara daju mogućnost da se
   tipovi parametara zaključuju na osnovu tipova drugih parametara.

   Jedan naivan prikaz problema kog rešavaju /fundeps/:

   #+CAPTION: haskellNTP/showcase/src/FunDeps.hs
   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "7-43"

   Kompajler prosto ne može da zna kog je tipa izraz =unpack c=.

   *Zašto?*

   Pokušajmo da reprodukujemo kako kompajler "razmišlja" na osnovu
   greške koju nam je dao.

   Prvo nam kaže da smo bili dvosmisleni pri korišćenju =unpack=
   funkcije jer on ne može da repreodukuje kako *tačno* izgleda klasa
   te funkcije. Jasno mu je da je ta klasa nešto nalik =(Unpack Carton
   content0)= ali ga muči taj =content0= jer za njega ne ume da kaže
   kog je tipa:

   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "29-33"

   I onda traži od nas da mu pomognemo. Kaže da bismo mi možda mogli
   da mu pomognemo tako što ćemo reći kog je tipa izraz =unpack c= pa
   će on onda umeti da shvati kako tačno izgleda klasa iz koje je ta
   funkcija:

   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "36-37"

   I na kraju nam još pokazuje kako razmišlja tako što nam kaže da je
   tražio *sve moguće instance* te sumnjive klase =Unpack= (i našao je
   jednu).

   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "37-40"

   Možda bismo se mogli _izleteti_ i uzviknuti:

   *Pa eto mu odgovora. Piše u toj instanci kog je tipa =unpack c=
   (naravno da je =Milk=)!*

   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "22-24"

   Međutim pogrešili bismo ( _naravno_ ).

   *Zašto?*

   Zato što se naknadno može dodati nova instanca =Unpack= klase. ♦

   Na primer:

   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "46-52"

   *Rešenje:*

   Možemo poslušati kompjler i eksplicitno dati tip izrazu:
   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "53-55"

   Možemo iskoristiti [[https://prime.haskell.org/wiki/FlexibleInstances][FlexibleInstances]] dodatak jeziku:
   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "56-59"

   I možemo koristi /fundeps/:

   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "64-73"

   Sada smo u zaglavlju klase =Unpack'= rekli da:

   *Za jedan =packaging= tip može biti samo jedan =content= tip*.

   I nema nikakve dileme kog je tipa =unpack' c= jer *ne može*
   postojati još jedna instanca klase =Unpack'= koja bi pravila
   problem:

   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "90-103"

   Naravno, u neku drugu ambalažu se može bez problema pakovati nešto
   drugo, to svakako neće praviti problem:

   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "74-89"

* Monoidi
* Funktori
* Aplikativni funktori
* Monade
** IO
* Profiling

  *Zašto je ovaj program spor?*

  *Zašto ovaj program koristi ovoliko memorije?*

  [[https://en.wikipedia.org/wiki/Profiling_(computer_programming)][Profiling]] je dinamička ili statička analiza programa koja služi da
  izmeri koliko i kako program troši resurse. Informacije koje daju
  profiler-i koriste se za optimizaciju.

  Kod funkcionalnih jezika osnovni nivo profiling-a odnosi se na
  merenje potrošnje resursa koju program pravi pri pozivu pojedinih
  funkcija.

  *Haskell funkcija A koristi funkciju A1* \\
  *Haskell funkcija A1 koristi funkciju A2* \\
  *Haskell funkcija B koristi funkciju B1* \\
  *Haskell funkcija B1 koristi funkciju B2* \\
  *Haskell funkcija A1 je spora i troši previše memorije. Šta nam
  garantuje da to nije zbog B1?*

** Primitivni profiling samo sa Unix =time=
** GHC podrška za profiling

   Izvodi se u tri koraka:

   1. Kompajliranje programa za profiling

      GHC ubaci delove koda koji nam omogućavaju da u vreme
      izvršavanja dobijamo informacije za profiling. To se mora
      naglasiti posebnim opcijama koje se daju kompajleru (pun spisak
      opcija potražiti [[https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html][ovde]]):

      #+BEGIN_SRC shell
        ghc -prof -fprof-auto-top -rtsopts Modul.hs
      #+END_SRC

      Moguće je ubaciti odgovarajuću pragmu (/cost centre annotation/)
      na mesta u porgramu koja posebno želimo da "merimo":

      #+BEGIN_SRC haskell :eval no
        {-# SCC ime_za_merenje #-}
      #+END_SRC

      Primer programa koji koristi eksplicitne /cost/ centre je dat u
      nastavku:

      <<ref:expl_cost_centers>>
      #+CAPTION: haskellNTP/profiling/src/ExplicitCostCenters.hs
      #+INCLUDE: "haskellNTP/profiling/src/ExplicitCostCenters.hs" src haskell :lines "5-"

      Kako bi ovakva mesta u programu bila merena potrebno je da pri
      kompajliranju [[https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/prof-compiler-options.html][bude omogućena opcija =-prof=]].

      Ako projekat koristi /stack/ sličan efekat komandi gore se može
      postići na sledeći način (imajte u vidu da =Stack= koristi
      =Cabal= a tek =Cabal= prosleđuje opcije GHC-u, pogledati [[https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md#debugging][ovde]]):

      #+BEGIN_SRC shell
        stack build --library-profiling --executable-profiling \
              --ghc-options="-fno-prof-cafs -rtsopts"
      #+END_SRC

   2. Pokretanje programa sa omogućenim opcijama za profiling

      #+BEGIN_SRC shell
        ./projekat-exe +RTS -p
      #+END_SRC

      Pun spisak /RTS/ opcija možete pogledati [[https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#time-and-allocation-profiling][ovde]].

      Ako koristite /stack/:

      #+BEGIN_SRC shell
        stack exec -- projekat-exe +RTS -p
      #+END_SRC

   3. Analiza rezultata

      Ako ste program izvršili sa RTS opcijom =-p= onda ste dobili
      fajl =program.prof= u kome se nalaze rezultati za analizu.

      Ako izvršimo prethodna dva koraka sa programom datim [[ref:expl_cost_centers][ranije]] naš
      =.prof= file će ličiti na:

      #+CAPTION: haskellNTP/profiling/profiling-exe-manual-CAFS.prof
      #+INCLUDE: "haskellNTP/profiling/profiling-exe-manual-CAFS.prof" src fundamental

*** Još neke /RTS/ (/Run Time System/) opcije

    Ako programu od [[ref:expl_cost_centers][ranije]] pro pokretanju prosledimo opciju =-pa=
    dobićemo širi izveštaj o korišćenju resursa koji će obuhvatati i
    podatke o alokaciji memorije:

    #+CAPTION: haskellNTP/profiling/profiling-exe-pa.prof
    #+INCLUDE: "haskellNTP/profiling/profiling-exe-pa.prof" src fundamental

    Listu ostalih opcija možete pogledati [[https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#time-and-allocation-profiling][ovde]].

*** Potrošnja memorije kroz vreme

    Ponekada je korisno pratiti i potrošnju memorije kroz
    vreme. Ovakvi izveštaji mogu lepo pokazati kojom dinamikom dolazi
    do /out of memory/ grešaka i zašto.

    Kako bismo pokrenuli program tako da dobijemo /heap/ profil
    potrebno je da koristimo /RTS/ opciju =-h= (ili neku drugu opciju
    koja nam omogućuje inspekciju korišćenja /heap/-a, a puna lista je
    data [[https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#rts-options-for-heap-profiling][ovde]]). I nakon toga dobijamo fajl =program.hp= u kome se
    nalaze merenja koja liče na:

    #+CAPTION: haskellNTP/profiling/profiling-exe-basic.hp
    #+INCLUDE: "haskellNTP/profiling/profiling-exe-basic.hp" src fundamental

    za vizualizaciju ovih rezultata može se koristiti program =hp2ps=:

    #+BEGIN_SRC shell
      stack exec -- hp2ps -d program-exe.hp
    #+END_SRC

    Za program:

    #+CAPTION: haskellNTP/profiling/src/Mean.hs
    #+INCLUDE: "haskellNTP/profiling/src/Mean.hs" src haskell :lines "5-"

    #+ATTR_HTML: :width 600px
    [[file:images/profiling-exe-mean.jpg]]

* Haskell Core                                                 :za_radoznale:

  Kada /profiling/ ne daje dovoljno dobar uvid u to šta program radi
  na niskim nivoima onda možda razumevanja /Haskell Core-a/ može da
  pomogne.

  [[https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType][/Haskell Core/]] je "jednostavan funkcionalan jezik" koji /GHC/
  koristi kao /intermediate/ reprezentaciju programa. /GHC/ optimizuje
  programe tako što ih sukcesivno transformiše u sve efikasnije
  forme. /Core/ predstavlja poslednji nivo na kome se očuvavaju
  pravila funkcionalnog programiranja pre prevođenja na imperativni -
  kod niskog nivoa (za šta se kod /GHC/-a koriste [[https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode][/STG/]] i /C--/).

  /Core/ je za razliku od Haskell-a veoma jednostavan jezik. Njegova
  sintaksa se može opisati u 20-ak linija, eksplicitno je tipiziran. I
  /sve konstrukcije u Haskell-u mogu se predstaviti pomoću Core
  jezika/.

  Kako bismo od kompajlera tržili da nam pokaže /Core/ verziju našeg
  programa treba da mu prosledimo opciju =-ddump-simpl= ili da
  koristimo =ghc-core= alat koji to (uz još par stvari) uradi za
  nas. Ako projekat koristi /Stack/ onda se to može uratiti na sledeći
  način:

  Instalirati =ghc-core=:

  #+BEGIN_SRC shell
    stack install ghc-core
  #+END_SRC

  /Stack/ će možda upozoriti da nema specificiranih verzija
  /dependencies/-a ali će dati i predlog šta treba uraditi, npr:

  #+BEGIN_SRC fundamental
    Recommended action: try adding the following to your extra-deps in
    /.../haskellNTP/profiling/stack.yaml:
    - colorize-haskell-1.0.1
  #+END_SRC

  Poslušaćemo predlog i izmeniti odgovarajuću liniju u =stack.yaml=
  projekta na:

  #+BEGIN_SRC yaml
    extra-deps: [colorize-haskell-1.0.1]
  #+END_SRC

  Nakon toga možemo ponovo pokrenuti instalaciju i posle toga:

  #+BEGIN_SRC shell
    stack exec -- ghc-core app/Main.hs
  #+END_SRC

  Što će na terminal ispisati sve transformacije našeg programa pa
  tako možemo ispratiti šta tačno radi kompajler.

  /GHC/ nam omogućuje da ispitujemo sve njegove nivoe kompajliranja pa
  tako i sam asembler na kraju. O tome možete čitati na kraju [[http://book.realworldhaskell.org/read/profiling-and-optimization.html][ovog]]
  poglavlja /Real World Haskell/-a.
* Literatura
  - [[http://learnyouahaskell.com/][Learn Some Haskell For The Great Good]]
  - [[https://wiki.haskell.org/Introduction][Haskell wiki]]
  - [[http://book.realworldhaskell.org/][Real World Haskell]] (odlična knjiga ali nije davno ažurirana)
  - [[http://www.seas.upenn.edu/~cis194/][Kursevi na Pensilvanija univerzitetu]] (/spring13/, /fall16/ ili
    bilo koji drugi po izboru.)
