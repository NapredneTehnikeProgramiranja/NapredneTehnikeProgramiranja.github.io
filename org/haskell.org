#+TITLE: Napredne tehnike programiranja - Haskell
#+LANGUAGE: sr
#+SETUPFILE: org-html-themes/setup/theme-bigblow.setup
#+PROPERTY: header-args:python :session osnove_programiranja :results output :exports both
#+TAGS: za_radoznale

#+ATTR_HTML: :width 400px
[[file:images/haskell_logo.png]]

#+BEGIN_QUOTE
An advanced, purely functional, statically typed, lazy programming
language.
#+END_QUOTE

* Uvod[fn:3]
  Haskell je čisto funkcionalan programski jezik opšte
  namene. Karakteriše ga [[https://en.wikipedia.org/wiki/Evaluation_strategy#Non-strict_evaluation][non-strict]] semantika i stroga statička
  tipizacija. Ime je dobio po logičaru [[https://en.wikipedia.org/wiki/Haskell_Curry][Haskell Curry]]-ju. Nastao je
  kasnih 80-tih godina kao rezultat rada grupe akademaca u oblasti
  računarskih nauka. Haskell je izgrađen oko veoma napredanog /type
  system/-a koji sadrži algoritam za zaključivanje tipova ([[https://en.wikipedia.org/wiki/Type_inference][type
  inference]]) pa se veoma malo jezičkih konstrukcija u kodu mora
  eksplicitno obeležiti tipovima.

  Haskell jasno nameće način razmišljanja. Jedino kod nastao čisto
  funkcionalnim načinom razmišljanja se može[fn:1] zapisati u
  Haskell-u.

  Pošto je "funckionalan programski jezik" veoma rastegljiv pojam
  odmah ovde na početku ćemo reći šta za nas znači da je Haskell
  funkcionalan:

  - Funkcije su prvoklasni koncepti.
  - Značenje Haskell programa je izgrađeno na osnovu izračunavanja
    izraza a ne na izvršavanju naredbi --- /Haskell nema naredbe/.

  Pošto je "čisto funkcionalan programski jezik" takođe rastegljiv
  pojam u poslednje vreme i to ćemo odmah na početku jasno
  odrediti. Kada kažemo da je Haskell čisto funkcionalan programski
  jezik to znači:

  - Nema mutiranja, nigde! Sve je imutabilno.
  - Izrazi nikada nemaju sporedne efekte (ni kod ispisivanja na
    ekran[fn:2]).
  - Sve funkcije za iste ulaze vraćaju iste izlaze.

  Haskell je istinski lenj. Dakle, _nije da većina funckija vraća
  lenje sekvence_ već nešto striktnije:

  - Izrazi ( _svi_, _bilo koji_ ) se ne evaluiraju dok njihov rezultat
    nije potreban za neko drugo izračunavanje.
  - Omogućuje kompozicijsko programiranje ([[*/Wholemeal/ programiranje][wholemeal programiranje]]).
  - To ima svoju manu --- rezonovanje o korišćenju vremena i prostora
    postaje dosta komplikovanije.

  Haskell je statički tipiziran jezik --- _svaki_ izraz ima svoj tip i
  svi tipovi se proveravaju u vreme kompajliranja. Program koji nije
  korektan sa stanovišta tipova se ne može kompajlirati a još manje
  pokrenuti. Tipovi izraza _nisu_ dostupni u vreme izvršavanja ---
  _nisu_ ni potrebni, kompajlirani kod je _korektan_ i to je dokazivo
  "matematikom koja stoji iza Haskell kompajlera".

  U nastavku ćemo dati neke ideje koje su od najveće važnosti u
  Haskell porgramiranju.

** Tipovi
   Haskell ima statički type sistem. Statički type sistemi propisuju
   da tipovi izraza (a u procedurnim jezivima objekata, promenljivih)
   moraju biti poznati u vreme kompajliranja.

   Kada programer u kodu mora da anotira sve izraze to može da bude
   prilično dosadna stvar. Ono što je bitno da zapamtimo je:

   #+BEGIN_QUOTE
   Obavezna anotacija svih izraza u programu _nije_ osobina statičkih
   type sistema već pre posledica nedovoljne ekspresivnosti _nekih_
   statičkih type sistema (kao što je slučaj kod Java, C, C++, C#...).
   #+END_QUOTE

   Haskell-ov type sistem nam daje sledeće stvari:

   - Pomaže nam da promislimo i izrazimo svoj program

     Prvi korak u pisanju Haskell programa je popišemo sve tipove koji
     su potrebni. Pošto je Haskell-ov type sistem prilično ekspresivan
     to nije trivijalan zadatak ali zato jeste veliki korak ka jasnom
     razumevanju strukture programa.

   - Služi kao forma dokumentacije

     Type sistem je toliko ekspresivan da čitanje tipa funkcije
     najčešće već samo govori sasvim dovoljno o tome šta funkcija radi
     pa tekst o tome šta funckija radi nije neophodan. Mnoge
     standardne Haskell funckije nemaju dokumentaciju u vidu teksta!

   - Pretvara /run-time/ greške u /compile-time/ greške

     Bolje je imati korektan program nakon kompajliranja nego
     beskrajno testirati u /run-time/-u. Haskell ima maksimu --- *ako
     se kompajlira onda je korektno*. Postoji mogućnost da se
     "provuče" neka greška vezana za logiku programa ali se i to u
     Haskell-u očekuje ređe nego u ostalim programskim jezicima.

** Apstrakcije
   "Don't Repeat Yourself" je česta mantra koja se čuje u današnjem
   programiranju, u nauci se zove još i /Princip Apstrakcije/. Idaja
   je da ništa ne treba pisati više puta: svaka ideja, algoritam,
   parče podatka treba da se pojavi samo na jednom jedinom mestu u
   kodu. Izdvajanje sličnih delova koda se naziva procesom
   apstrakcije.

   Haskell je vrlo dobar u apstrahovanju. Koncepti kao što su
   /parametric polymorphism/, funkcije višeg reda, /type classes/ i
   drugi za cilj imaju da se izbore za princip apstrakcije.

   #+BEGIN_QUOTE
   Da li je Vaš softver /DRY/?

   Šta je Vaš izgovor?
   #+END_QUOTE

** /Wholemeal/ programiranje
   Citat [[http://www.cs.ox.ac.uk/ralf.hinze/][Ralf Hinze]]:

   #+BEGIN_QUOTE
   “Functional languages excel at wholemeal programming, a term coined
   by Geraint Jones. Wholemeal programming means to think big: work
   with an entire list, rather than a sequence of elements; develop a
   solution space, rather than an individual solution; imagine a
   graph, rather than a single path. The wholemeal approach often
   offers new insights or provides new perspectives on a given
   problem. It is nicely complemented by the idea of projective
   programming: first solve a more general problem, then extract the
   interesting bits and pieces by transforming the general program
   into more specialised ones.”
   #+END_QUOTE

   /Wholemeal/ programiranje je dakle [[https://sh.wikipedia.org/wiki/Dedukcija][deduktivan]] proces.

   Pogledajmo ovo parče pseudo Java/C#/C... koda:

   #+BEGIN_SRC c
     int acc = 0;
     for ( int i = 0; i < lst.length; i++ ) {
         acc = acc + 3 * lst[i];
     }
   #+END_SRC

   [[http://www.cs.ox.ac.uk/people/richard.bird/][Richard Bird]] kaže da ovo parče koda boluje od "indeksitisa": brine
   se o iteriranju kroz niz na niskom nivou --- tako što prati
   indekse. Pored toga još i meša u jedno ono što se obično smatra kao
   dve operacije --- uvećavanje svakog elementa za 3 i sabiranje svih
   elemenata. U Haskell-u to bismo uradili ovako:

   #+BEGIN_SRC haskell
     sum $ map (3*) lst
   #+END_SRC

** Elementi jezika
   Možemo reći da se Haskell sastoji iz dva jezika: *jezik tipova* i
   *jezik izraza* gde prvi nije obavezno pisati jer /type inference/
   algoritam ume da zaključi informacije koje on nosi. Konstrukcija
   =::= razdvaja ova dva jezika.

   #+BEGIN_SRC haskell
     jezik izraza :: jezik tipova
   #+END_SRC

   =::= se još čita i "ima tip".

*** Dekleracije i variable

    Deklarisanje promenljivih možemo uraditi na sledeći način:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "3-9"

    Kod iznad deklariše variablu koja ima tip =Int= i
    vrednost 3. Imajte u vidu da se ova promenljiva *ne može* više
    nikada promeniti ona će do kraja sveta(dobro programa) imati
    vrednost koju smo joj ovde zadali. Takođe, ako pokušamo negde
    drugo ponovo da deklarišemo ovu istu variablu kompajler će
    prijaviti grešku:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "10-16"

    Dakle, /=/ *ne predstavlja* /dodelu/ kao što je slučaj u mnogim
    drugim jezicima već /definiciju/ kao u matematici. Dakle =x = 1=
    se *ne čita* kao "x dobija vrednost 1" ili "dodeljujem broj 4
    promenljivoj x" već *"x je definisano kao 1"*. Šta radi sledeći
    kod?

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "17-19"

*** Osnovni tipovi
    =Int= je osnovni celobrojni tip i po standardu mora biti u stanju
    da prikaže vrednosti u opsegu ne manjem od $\pm2^{29}$. Na
    standardnim 64-bitnim mašinama je $\pm2^{63}$. Maksimalna i
    minimalna vrednost =Int= tipa su date sa =biggestInt= i
    =smallestInt=:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "20-27"

    =Integer= tip je proizvoljne preciznosti i ograničen je samo
    memorijom računara:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "28-40"

    =Float= je standardan tip za predstavu razlomljenih brojeva u
    /single-precision/, =Double= je /double-precision/:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "41-48"

    Tu su i =Bool=, =Char= i =String=:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "49-60"

*** Aritmetika
    Probajmo sledeće izraze:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "61-69"

    - /backticks/ prefiksnu funkciju pretvaraju u infiksnu
    - minusi kao znakovi moraju biti u zagradama kako ne bi bili
      parsirani kao oduzimanje

    Sledeći izraz ne prolazi kompajler:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "70-76"

    Haskell neće raditi implicitnu konverziju između ova dva tipa,
    morate Vi eksplicitno:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "77-80"

    Ovo takođe ne prolazi kompajler:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "81-86"

    Za deljenje celobrojnih vrednosti moramo da koristimo =div=:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "87-90"

*** Boolova logika
    Ovo radi kako ste i navikli:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "91-99"

*** Definisanje osnovnih funkcija
    Funkcije se definišu na sledeći način:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "100-104"

    =Integer -> Integer= znači da funkcija prima =Integer= i vraća
    =Integer=.

    U definiciji funkcije prvi izraz koji odgovara pozivu se
    izvršava. Objasnite izvršavanje funkcije =sumtorial=?

    Izbor poziva takođe može biti izražen i korišćenjem mehanizma koji
    se zove /guards/:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "105-109"

    /Guards/ se izvršavaju redom --- od gore ka dole i prvi izraz koji
    se evaluira u =True= će izazvati da se izvrši njegova grana
    funkcije.

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "110-119"

    Šta će biti =foo(-3)=, =foo(0)=, =foo(1)=, =foo(36)=, =foo(38)=?

*** Parovi
    Parovi služe da uparimo neke dve informacije. Postoje i ostale
    n-torke ali se u praksi uglavnom koriste parovi jer za ostalo
    posotje bolji načini predstavljanja.

   #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "120-122"

   Obratiti pažnju da su n-torke različitihj tipova:

   #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "123-131"

   N-torkama se u praksi najčešće pristupa [[https://en.wikipedia.org/wiki/Pattern_matching][pattern matching]]-om:

   #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "132-136"

*** Funkcije više argumenata
    Funkcija sa više argumenata se definiše na sledeći način:

   #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "137-142"

   Ako Vam tip funkcije =multiArgFoo :: Int -> Int -> Int -> Int=
   deluje čudno i pitate se:

   #+BEGIN_QUOTE
   Zašto ovoliko strelica, funkcija prima 3 parametra i vraća jededan
   zar ne bi više imalo smisla da bude nešto kao =Int Int Int -> Int=?
   #+END_QUOTE

   onda ste na dobrom tragu. Razlog za ovo je dosta dublji od same
   sintakse i ima valjan razlog u matematici. Razlog za ovakvu
   notaciju je [[https://wiki.haskell.org/Currying][Currying]].

   #+BEGIN_QUOTE
   /Currying/ je proces transformacije funckije koja prima više
   argumenata u funckiju koja prima samo jedan argument i vraća drugu
   funkciju ako su još neki parametri potrebni.
   #+END_QUOTE

   Pa tako:

   #+BEGIN_SRC haskell
     λ> foo = multiArgFoo 1
     λ> :t foo
     foo :: Int -> Int -> Int
     λ> foo1 = foo 2
     λ> :t foo1
     foo1 :: Int -> Int
     λ> res = foo1 3
     λ> :t res
     res :: Int
     λ> res
     6
   #+END_SRC

   Ovo podseća na parcijalnu primenu funkcije ali _to nije baš
   to_. Pogledajte ovu diskusiju na [[https://stackoverflow.com/questions/218025/what-is-the-difference-between-currying-and-partial-application][StackOverflow]] (barem prva dva
   odgovora).

*** Liste
    Liste su jedne od najosnovnih struktura podataka Haskell-a.

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "142-158"

    Postoji i /list comprehension/:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "158-166"

*** Konstrukcija listi
    Sve liste se grade od prazne liste korišćenjem =cons= operatora
    (=:=). Ovo Vam je možda poznato iz Lispa?

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "167-171"

    Obratite pažnju da su ovo prave jednostruko spregnute liste a ne
    nizovi. Uzgred, šta je razlika između niza i jednostruko spregnute
    liste?

*** Funkcije nad listama
    Funkcije koje rade sa listama takođe koriste /pattern matching/:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "171-176"

    Pošto prvi element liste ne koristimo ne moramo ni da koirstimo
    ime za njega i zato imamo =intListLength (_:xs)=. Ovo je
    rekurzija, uslov završetka je dat elegantno zar ne?

    Paterni mogu da se ugnježdavaju:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "177-181"

*** Kombinovanje funkcija
    Haskell kao funckionalan jezik inspiriše da rešenja većih problema
    gradimo kroz rešavanje manjih porcija problema. Pa tako kopleksne
    funkcije gradimo kombinovanjem jednostavnijijh.

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "182-193"

    Kako vam ovo deluje?

    Možda mislite: ovo nije memorijski efikasno, treba da potroši
    vreme i memoriju da napravi celu [[https://en.wikipedia.org/wiki/3x_%252B_1_problem][hailstone]] sekvencu od =n= pa onda
    da računa njenu dužinu.

    Zapravo, zahvaljujući lenjoj eveluaciji čitavo računanje koristi
    =O(1)= momoriju bez obzira na dužinu sekvence. Zapravo _skoro_
    O(n) ali o tome će biti reči kasnije. Sada možete da probate to u
    praksi, probajte:

    #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "194-198"

*** Pragme
    ={-# LANGUAGE #-}= ={-# OPTIONS_GHC #-}= ={-# INCLUDE #-}= ={-# INFIX #-}=
    ={-# DEPRECATED #-}= ={-# WARNING #-}= ={-# RULES #-}=
** Kompajler (GHC)
   Haskell ima više različitih kompajlera (kao što C ima GCC,
   Clang...) ali je [[https://www.haskell.org/ghc/][GHC]] definitivno najkorišćeniji. Sam GHC kao
   kompajler je prilično pametno dizajniran i predstavlja jedan od
   najnaprednijih kompajlera danas. Na ovom kursu koristićemo samo GHC
   i nećemo diskutovati o ostalim kompajlerima.

*** /Type inference/
    Haskell je implicitno tipiziran jezik (/implicitly-typed/) za
    razliku od C/C++, Java, C#, Go i dr. koji su eksplicitno
    tipizirani (/explicitly-typed/). To praktično znači da u kodu ne
    mora stajati tip za sve izraze već kompajler sam ume da zaključi
    tipove. Dakle, tipovi su poznati u vreme kompajliranja (pre
    pokretanja porgrama) ali nisu eksplicitno napisani u kodu.

** GHCi
   GHCi je Haskell REPL (ne toliko moćan kao u Clojure-u zbog statičke
   prirode Haskell-a). Listu opcija koju pruža možete naći sa =:?=:

   #+BEGIN_SRC haskell
     λ> :?
      Commands available from the prompt:

        <statement>                 evaluate/run <statement>
        :                           repeat last command
        :{\n ..lines.. \n:}\n       multiline command
        :add [*]<module> ...        add module(s) to the current target set
        :browse[!] [[*]<mod>]       display the names defined by module <mod>
                                    (!: more details; *: all top-level names)
        :cd <dir>                   change directory to <dir>
        :cmd <expr>                 run the commands returned by <expr>::IO String
        :complete <dom> [<rng>] <s> list completions for partial input string
        :ctags[!] [<file>]          create tags file <file> for Vi (default: "tags")
                                    (!: use regex instead of line number)
        :def <cmd> <expr>           define command :<cmd> (later defined command has
                                    precedence, ::<cmd> is always a builtin command)
        :edit <file>                edit file
        :edit                       edit last module
        :etags [<file>]             create tags file <file> for Emacs (default: "TAGS")
        :help, :?                   display this list of commands
        :info[!] [<name> ...]       display information about the given names
                                    (!: do not filter instances)
        :issafe [<mod>]             display safe haskell information of module <mod>
        :kind[!] <type>             show the kind of <type>
                                    (!: also print the normalised type)
        :load[!] [*]<module> ...    load module(s) and their dependents
                                    (!: defer type errors)
        :main [<arguments> ...]     run the main function with the given arguments
        :module [+/-] [*]<mod> ...  set the context for expression evaluation
        :quit                       exit GHCi
        :reload[!]                  reload the current module set
                                    (!: defer type errors)
        :run function [<arguments> ...] run the function with the given arguments
        :script <file>              run the script <file>
        :type <expr>                show the type of <expr>
        :undef <cmd>                undefine user-defined command :<cmd>
        :!<command>                 run the shell command <command>

      -- Commands for debugging:

        :abandon                    at a breakpoint, abandon current computation
        :back [<n>]                 go back in the history N steps (after :trace)
        :break [<mod>] <l> [<col>]  set a breakpoint at the specified location
        :break <name>               set a breakpoint on the specified function
        :continue                   resume after a breakpoint
        :delete <number>            delete the specified breakpoint
        :delete *                   delete all breakpoints
        :force <expr>               print <expr>, forcing unevaluated parts
        :forward [<n>]              go forward in the history N step s(after :back)
        :history [<n>]              after :trace, show the execution history
        :list                       show the source code around current breakpoint
        :list <identifier>          show the source code for <identifier>
        :list [<module>] <line>     show the source code around line number <line>
        :print [<name> ...]         show a value without forcing its computation
        :sprint [<name> ...]        simplified version of :print
        :step                       single-step after stopping at a breakpoint
        :step <expr>                single-step into <expr>
        :steplocal                  single-step within the current top-level binding
        :stepmodule                 single-step restricted to the current module
        :trace                      trace after stopping at a breakpoint
        :trace <expr>               evaluate <expr> with tracing on (see :history)

      -- Commands for changing settings:

        :set <option> ...           set options
        :seti <option> ...          set options for interactive evaluation only
        :set args <arg> ...         set the arguments returned by System.getArgs
        :set prog <progname>        set the value returned by System.getProgName
        :set prompt <prompt>        set the prompt used in GHCi
        :set prompt2 <prompt>       set the continuation prompt used in GHCi
        :set editor <cmd>           set the command used for :edit
        :set stop [<n>] <cmd>       set the command to run when a breakpoint is hit
        :unset <option> ...         unset options

       Options for ':set' and ':unset':

         +m            allow multiline commands
         +r            revert top-level expressions after each evaluation
         +s            print timing/memory stats after each evaluation
         +t            print type after evaluation
         +c            collect type/location info after loading modules
         -<flags>      most GHC command line flags can also be set here
                              (eg. -v2, -XFlexibleInstances, etc.)
                         for GHCi-specific flags, see User's Guide,
                         Flag reference, Interactive-mode options

      -- Commands for displaying information:

        :show bindings              show the current bindings made at the prompt
        :show breaks                show the active breakpoints
        :show context               show the breakpoint context
        :show imports               show the current imports
        :show linker                show current linker state
        :show modules               show the currently loaded modules
        :show packages              show the currently active package flags
        :show paths                 show the currently active search paths
        :show language              show the currently active language flags
        :show <setting>             show value of <setting>, which is one of
                                       [args, prog, prompt, editor, stop]
        :showi language             show language flags for interactive evaluation

   #+END_SRC
** IDE
   Haskell je podržan u svim u poznatijim razvojnim alatima.

   - Emacs
     - [[https://github.com/haskell/haskell-mode][haskell-mode]], [[https://github.com/commercialhaskell/intero][intero]] i drugi dodatni paketi po ukusu
     - za ljude koji počinju sa Emacs-om preporučujem [[http://spacemacs.org/][Spacemacs]] koji
       već ima [[https://github.com/syl20bnr/spacemacs/tree/master/layers/%252Blang/haskell][sloj]] za Haskell u kome su standardni alati već
       podešeni.
   - Vim [[https://github.com/begriffs/haskell-vim-now][haskell-vim-now]]
   - Eclipse [[http://eclipsefp.github.io/][EclipseFP]]
   - IntelliJ [[https://github.com/rikvdkleij/intellij-haskell][intellij-haskell]]
   - Atom [[https://atom.io/packages/ide-haskell][ide-haskell]]
   - [[http://leksah.org/][Leksah]]

*** Hoogle
    [[https://www.haskell.org/hoogle/][Hoogle]] je sajt na kome možete pretraživati dokumentaciju. Podržava
    jezik za postavljanje upita. Može se veoma jednostavno pokretati i
    u lokalu.

*** Stack & Stackage
    [[https://docs.haskellstack.org/en/stable/README/][Stack]] je standardan /build tool/ i /dependency manager/. Projekti
    sa kodom koji vidite u ovoj prezentaciji a koji su dostupni na
    [[https://github.com/NapredneTehnikeProgramiranja/haskellNTP][GitHub-u]] su pod kontrolom Stack-a. Pojednostavljuje rad sa
    Haskell-om tako da više liči na proces razvoja softvera u
    Python-u, JavaScript-u, Javi... Preporučujem ga pre [[https://www.haskell.org/platform/][/haskell
    platform/]]-e.

    [[https://www.stackage.org/][Stackage]] je centralni repozitorijum koji koristi Stack. Njihov
    odnos je sličan odnosu /PIP/-a i /PyPI/-a u Python svetu.

** Čitanje poruka o grešci
   Nemojte se plašiti poruka o grešci.

   *GHC-ove poruke o grešci nisu duge nego su informativne.*

   Poruke o grešci sadrže mnogo informacija iz kojih vidite zašto
   nešto "nije po volji" kompajlera. Iz tih grešaka, ako umete da ih
   čitate, možete da naučite bitne stvari.

   #+INCLUDE: "haskellNTP/showcase/src/Intro.hs" src haskell :lines "199-205"

   Šta kaže ova greška?

   - Očeluje se =[Char]= tip, a nađen je =Int=
   - kod prvog argumenta funkcije =(++)=, tačnije =x=.
   - u izrazu =x ++ "string"=
   - u jednačini za (=it= je variabla koja će uvek imati vrednost
     izraza koju ste predhodno uneli u GHCi): =it = x ++ "string"=

** Ograničenja GHC kompajlera                                  :za_radoznale:
*** Monomorfizam restrikcija
    https://wiki.haskell.org/Monomorphism_restriction

** Zadaci 1
   Na kursu [[http://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf][cis194]] su data dva zadatka, smatram ih vrlo ilustrativnim
   za uvod u Haskell :)

   1. Napisati funkciju =validate= za validiranje broja platne kartice
   2. Napisati funkciju =hanoi= koja prima broj diskova [[https://en.wikipedia.org/wiki/Tower_of_Hanoi][Hanoi]] tornjeva
      i daje listu poteza koje treba preduzeti da bi se diskovi
      pravilno preneli sa jednog na drugi toranj.

* Funkcije
  Funkcije se pišu slično kao u matematici. O Haskell funkcijama treba
  razmišljati više na matematički način a menje kao o
  procedurama/rutinama u proceduralnom programiranju:

  #+BEGIN_SRC haskell
    (fooIme :: <izraz_za_tip>)?
    (<definicija_za_fooIme>)+
  #+END_SRC

  Primer jedne funkcije:

  #+INCLUDE: "haskellNTP/showcase/src/Functions.hs" src haskell :lines "3-8"

  Funkcije podržavaju /pattern matching/. Funkcije se često pišu uz
  korišćenje /guards/ mehanizma. =case= izraz se retko koristi za
  rukovanje parametrima funkcije jer za njim retko ima potrebe. =case=
  izraz takođe podržava /pattern matching/.

  #+INCLUDE: "haskellNTP/showcase/src/Functions.hs" src haskell :lines "9-18"

  =case= izraz može da koristi /quards/:

  #+INCLUDE: "haskellNTP/showcase/src/Functions.hs" src haskell :lines "19-30"

  =case= može da kombinuje /pattern matching/ i /quards/:

  #+INCLUDE: "haskellNTP/showcase/src/Functions.hs" src haskell :lines "31-42"

* Data deklaracije
  Postoje tri osnovna načina na koja možete uvesti novi tip u Haskell:
  =data=, =newtype= i =type=.

** =data=
   Standardan način za uvođenje novih tipova:

  #+INCLUDE: "haskellNTP/showcase/src/DataDeclarations.hs" src haskell :lines "5-10"

  Obratite pažnju da =Person= levo od znaka jednakosti i =Person=
  desno od znaka jednakosti nisu iste stvari. Ono sa leve strane unosi
  novi pojam u jezik tipova dok ono sa desne strane unosi novi pojam u
  jezik izraza. U primeru gore samo se slučajno isto zovu. Evo
  primera:

  #+INCLUDE: "haskellNTP/showcase/src/DataDeclarations.hs" src haskell :lines "11-16"

  =MkPerson= je u jeziku izraza, a =Person1= u jeziku tipova.

  Ono sa leve strane jednakosti naziva se /type constructor/ jer
  konstruiše tip u jeziku tipova, ono sa desne strane se naziva /data
  constructor/ jer konstruiše vrednost tog tipa u jeziku izraza.

  Pogledajmo sledeći primer:

  #+INCLUDE: "haskellNTP/showcase/src/DataDeclarations.hs" src haskell :lines "37-64"

  Tipovi kao što su =CardValue= i =Suit= gde specificiramo oblik
  svakog elementa zovu se [[https://wiki.haskell.org/Algebraic_data_type][algebartski tipovi]]. Algebarski tipovi se
  tako zovu jer se definišu korišćenjem "algebarskih" operacija
  ("algebra" ovde praktično znači operaciju sabiranja --- izbora =A |
  B= i množenja --- kombinacije =A B=). Npr. naš prvi tip =Person= je
  kombinacija dva =String=-a, =Suit= je izbor jedne od boja na
  kartama.

  Tipovi mogu biti i parametrizovani:

  #+INCLUDE: "haskellNTP/showcase/src/DataDeclarations.hs" src haskell :lines "65-71"

*** Records sintaksa
    Postoji i alternativni način za uvođenje novih tipova kada se
    koristi =data= --- /records syntax/:

    #+INCLUDE: "haskellNTP/showcase/src/DataDeclarations.hs" src haskell :lines "17-36"

** =newtype=
   =newtype= dekleracija uvodi novi tip na isti način kao što to radi
   =data=. Ako u vašem programu sve pojave =newtype= zamenite sa
   =data= velike su šanse da će se kompajlirati(dakle raditi). Ali
   konverzija u suprotnom smeru stoji samo pod jednim uslovom --- ako
   =data= dekleracije imaju samo jedan /value/ konstruktor sa samo
   jednim parametrom:

   #+INCLUDE: "haskellNTP/showcase/src/DataDeclarations.hs" src haskell :lines "72-74"

   Vrednost =newtype= dekleracije je u tome što uvodi tipove koji
   _nemaju nikakvu cenu_ u /run time/-u --- u /run time/-u se mogu
   predstaviti "bit za bit" isto kao i tipovi koje obavijaju. U
   slučaju iznad kompajler će znati da su tipovi =HTML= i =String=
   potpuno različiti, ni jedna funkcija koja prima/vraća =HTML= _ne
   može_ umesto njega da koristi =String=. Tako dobijamo sve benefite
   komplajlera jer on razlikuje tipove bez obzira što se ti tipovi u
   /run time/-u reprezentuju na "bit za bit" isti način.

** =type=
   Type dekleracija uvodi sinonime za tipove --- /type synonyms/. U
   /C/-u se to na primer radi sa =typedef=. Tipovi uvedeni sa =type=
   imaju iste /value/ konstruktore kao i osnovni tip i u svim izrazima
   gde se pojavljuje osnovni tip mogu stajati umesto njega.

   #+INCLUDE: "haskellNTP/showcase/src/DataDeclarations.hs" src haskell :lines "75-90"

* Kinds
  Tipovi u svojoj osnovi predstavljaju skupove vrednosti. Tako je
  =Integer= skup svih celih brojeva, =[Bool]= skup svih lista
  istinitosnih vrednosti.

  Haskell koristi još opširniju definiciju tipa koja obuhvata i
  funkcije nad tipovima. Pa se tako neprimenjen konstruktor list tipa
  =[]= takođe smatra tipom. Parcijalno primenjen konstruktor tipa
  funkcije =(->) Integer= takođe. Ovi tipovi svakako ne sadrže
  vrednosti.

  Kako bi razlikovao obične tipove od funkcija nad tipovima Haskell
  koristi /system of kinds/ (sistem rodova - u slobodnom
  prevodu). /Kinds/ se mogu zamisliti kao "tipovi tipova". Svaki
  /kind/ je ili =*= ili =kind1 -> kind2= gde su =kind1= i =kind2=
  takođe /kinds/. =*= je /kind/ svih običnih tipova (onih koji sadrže
  vrednosti) a =kind1 -> kind2= je /kind/ svih funkcija na nivou tipa
  koje preslikavaju =kind1= u =kind2=. Evo nekih primera tipova i
  njihovih /kind/-a:

  #+BEGIN_SRC haskell
    Integer, Char, [Bool], [[Bool]], [val] :: *
    [], Maybe :: * -> *
    (,), (->) :: * -> * -> *
  #+END_SRC

  Funkcije na nivou tipova koje primaju više parametara mogu biti
  izražene kroz /Currying/:

  #+BEGIN_SRC haskell
    (,), (->) :: * -> * -> *
  #+END_SRC

  Dobar blog na ovu temu nalazi se [[https://jeltsch.wordpress.com/2013/02/09/some-interesting-features-of-haskells-type-system/][ovde]].

* Haskell --- lazy by default
** /Strict evaluation vs. lazy evaluation/

*** Cena /strict/ izračunavanja

*** Cena /lazy/ izračunavanja

** Haskell /laziness look and feel/ vs. Java /Supliers/ ("/type level laziness/")
   Java je na [[https://www.sitepoint.com/java-in-praise-of-laziness/][SitePoint-u]]. Haskell je na [[http://www.seas.upenn.edu/~cis194/spring13/lectures/06-laziness.html][CIS-u]].

* Polimorfizam
  Vrsta polimorfizma koju haskell koristi je [[https://en.wikipedia.org/wiki/Parametric_polymorphism][parametarski
  polimorfizam]].
* GADTs
* Type Classes
  /Type class/-e predstavljaju skupove tipova koji ispoljavaju neke
  iste osobine. Te iste osobine oslikane su funkcijama koje obuhvata
  klasa.

  =Eq= je klasa koja predstavlja skup tipova koji mogu da se porede:

  #+BEGIN_SRC haskell
    class Eq a where
      (==) :: a -> a -> Bool
      (/=) :: a -> a -> Bool
  #+END_SRC

  Ako želimo da naš tip može da se poredi treba da napravimo instancu
  našeg tipa u =Eq= klasi.

   #+INCLUDE: "haskellNTP/showcase/src/TypeClasses.hs" src haskell :lines "5-18"

** Automatsko instanciranje sa =deriving=
   Kada je situacija dovoljno prosta, kompajler može samostalno da
   uradi proširenje /type class/-e. Da bismo naznačili da to želimo
   treba da koristimo =deriving=:

   #+INCLUDE: "haskellNTP/showcase/src/TypeClasses.hs" src haskell :lines "19-26"

   U primeru sa =Foo= smo takođe mogli samo da iskoristimo =deriving=.

** =class= NIJE =class= iz Pythona i Jave

   Ono što je =type class= u Haskell-u to je sličnije abstraktnim
   klasama u Javi i Pythonu.

   #+CAPTION: haskellNTP/showcase/src/Hierarchies.hs
   #+INCLUDE: "haskellNTP/showcase/src/Hierarchies.hs" src haskell :lines "3-75"

** /fundeps/ (Functional Dependencies)
   [[https://wiki.haskell.org/Functional_dependencies][/Fundeps/]] se koriste da daju dodatna međusobna ograničenja
   parametara klasa. U klasama sa više parametara daju mogućnost da se
   tipovi parametara zaključuju na osnovu tipova drugih parametara.

   Jedan naivan prikaz problema kog rešavaju /fundeps/:

   #+CAPTION: haskellNTP/showcase/src/FunDeps.hs
   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "7-43"

   Kompajler prosto ne može da zna kog je tipa izraz =unpack c=.

   *Zašto?*

   Pokušajmo da reprodukujemo kako kompajler "razmišlja" na osnovu
   greške koju nam je dao.

   Prvo nam kaže da smo bili dvosmisleni pri korišćenju =unpack=
   funkcije jer on ne može da repreodukuje kako *tačno* izgleda klasa
   te funkcije. Jasno mu je da je ta klasa nešto nalik =(Unpack Carton
   content0)= ali ga muči taj =content0= jer za njega ne ume da kaže
   kog je tipa:

   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "29-33"

   I onda traži od nas da mu pomognemo. Kaže da bismo mi možda mogli
   da mu pomognemo tako što ćemo reći kog je tipa izraz =unpack c= pa
   će on onda umeti da shvati kako tačno izgleda klasa iz koje je ta
   funkcija:

   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "36-37"

   I na kraju nam još pokazuje kako razmišlja tako što nam kaže da je
   tražio *sve moguće instance* te sumnjive klase =Unpack= (i našao je
   jednu).

   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "37-40"

   Možda bismo se mogli _izleteti_ i uzviknuti:

   *Pa eto mu odgovora. Piše u toj instanci kog je tipa =unpack c=
   (naravno da je =Milk=)!*

   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "22-24"

   Međutim pogrešili bismo ( _naravno_ ).

   *Zašto?*

   Zato što se naknadno može dodati nova instanca =Unpack= klase. ♦

   Na primer:

   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "46-52"

   *Rešenje:*

   Možemo poslušati kompjler i eksplicitno dati tip izrazu:
   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "53-55"

   Možemo iskoristiti [[https://prime.haskell.org/wiki/FlexibleInstances][FlexibleInstances]] dodatak jeziku:
   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "56-59"

   I možemo koristi /fundeps/:

   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "64-73"

   Sada smo u zaglavlju klase =Unpack'= rekli da:

   *Za jedan =packaging= tip može biti samo jedan =content= tip*.

   I nema nikakve dileme kog je tipa =unpack' c= jer *ne može*
   postojati još jedna instanca klase =Unpack'= koja bi pravila
   problem:

   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "90-103"

   Naravno, u neku drugu ambalažu se može bez problema pakovati nešto
   drugo, to svakako neće praviti problem:

   #+INCLUDE: "haskellNTP/showcase/src/FunDeps.hs" src haskell :lines "74-89"

** Zadaci 2
   Vaša aplikacija je u produkciji i često se dešava nešto čudno što
   dovodi do otkaza. Vaš zadatak je da parsirate [[http://www.seas.upenn.edu/~cis194/spring13/extras/02-ADTs/error.log][logove]] koje pravi
   aplikacija i utvrdite šta je u pitanju. Pun opis zadatka i smernice
   su na [[http://www.seas.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf][cis194]]. Potrebni fajlovi su:

   - [[http://www.seas.upenn.edu/~cis194/spring13/extras/02-ADTs/sample.log][sample.log]]
   - [[http://www.seas.upenn.edu/~cis194/spring13/extras/02-ADTs/Log.hs][Log.hs]]

* Monoidi
* Funktori
* Aplikativni funktori
* Monade
** Kleisli kategorija
** IO
* Profiling

  *Zašto je ovaj program spor?*

  *Zašto ovaj program koristi ovoliko memorije?*

  [[https://en.wikipedia.org/wiki/Profiling_(computer_programming)][Profiling]] je dinamička ili statička analiza programa koja služi da
  izmeri koliko i kako program troši resurse. Informacije koje daju
  profiler-i koriste se za optimizaciju.

  Kod funkcionalnih jezika osnovni nivo profiling-a odnosi se na
  merenje potrošnje resursa koju program pravi pri pozivu pojedinih
  funkcija.

  *Haskell funkcija A koristi funkciju A1* \\
  *Haskell funkcija A1 koristi funkciju A2* \\
  *Haskell funkcija B koristi funkciju B1* \\
  *Haskell funkcija B1 koristi funkciju B2* \\
  *Haskell funkcija A1 je spora i troši previše memorije. Šta nam
  garantuje da to nije zbog B1?*

** Primitivni profiling samo sa Unix =time=
** GHC podrška za profiling

   Izvodi se u tri koraka:

   1. Kompajliranje programa za profiling

      GHC ubaci delove koda koji nam omogućavaju da u vreme
      izvršavanja dobijamo informacije za profiling. To se mora
      naglasiti posebnim opcijama koje se daju kompajleru (pun spisak
      opcija potražiti [[https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html][ovde]]):

      #+BEGIN_SRC shell
        ghc -prof -fprof-auto-top -rtsopts Modul.hs
      #+END_SRC

      Moguće je ubaciti odgovarajuću pragmu (/cost centre annotation/)
      na mesta u porgramu koja posebno želimo da "merimo":

      #+BEGIN_SRC haskell :eval no
        {-# SCC ime_za_merenje #-}
      #+END_SRC

      Primer programa koji koristi eksplicitne /cost/ centre je dat u
      nastavku:

      <<ref:expl_cost_centers>>
      #+CAPTION: haskellNTP/profiling/src/ExplicitCostCenters.hs
      #+INCLUDE: "haskellNTP/profiling/src/ExplicitCostCenters.hs" src haskell :lines "5-"

      Kako bi ovakva mesta u programu bila merena potrebno je da pri
      kompajliranju [[https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/prof-compiler-options.html][bude omogućena opcija =-prof=]].

      Ako projekat koristi /stack/ sličan efekat komandi gore se može
      postići na sledeći način (imajte u vidu da =Stack= koristi
      =Cabal= a tek =Cabal= prosleđuje opcije GHC-u, pogledati [[https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md#debugging][ovde]]):

      #+BEGIN_SRC shell
        stack build --library-profiling --executable-profiling \
              --ghc-options="-fno-prof-cafs -rtsopts"
      #+END_SRC

   2. Pokretanje programa sa omogućenim opcijama za profiling

      #+BEGIN_SRC shell
        ./projekat-exe +RTS -p
      #+END_SRC

      Pun spisak /RTS/ opcija možete pogledati [[https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#time-and-allocation-profiling][ovde]].

      Ako koristite /stack/:

      #+BEGIN_SRC shell
        stack exec -- projekat-exe +RTS -p
      #+END_SRC

   3. Analiza rezultata

      Ako ste program izvršili sa RTS opcijom =-p= onda ste dobili
      fajl =program.prof= u kome se nalaze rezultati za analizu.

      Ako izvršimo prethodna dva koraka sa programom datim [[ref:expl_cost_centers][ranije]] naš
      =.prof= file će ličiti na:

      #+CAPTION: haskellNTP/profiling/profiling-exe-manual-CAFS.prof
      #+INCLUDE: "haskellNTP/profiling/profiling-exe-manual-CAFS.prof" src fundamental

*** Još neke /RTS/ (/Run Time System/) opcije

    Ako programu od [[ref:expl_cost_centers][ranije]] pro pokretanju prosledimo opciju =-pa=
    dobićemo širi izveštaj o korišćenju resursa koji će obuhvatati i
    podatke o alokaciji memorije:

    #+CAPTION: haskellNTP/profiling/profiling-exe-pa.prof
    #+INCLUDE: "haskellNTP/profiling/profiling-exe-pa.prof" src fundamental

    Listu ostalih opcija možete pogledati [[https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#time-and-allocation-profiling][ovde]].

*** Potrošnja memorije kroz vreme

    Ponekada je korisno pratiti i potrošnju memorije kroz
    vreme. Ovakvi izveštaji mogu lepo pokazati kojom dinamikom dolazi
    do /out of memory/ grešaka i zašto.

    Kako bismo pokrenuli program tako da dobijemo /heap/ profil
    potrebno je da koristimo /RTS/ opciju =-h= (ili neku drugu opciju
    koja nam omogućuje inspekciju korišćenja /heap/-a, a puna lista je
    data [[https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#rts-options-for-heap-profiling][ovde]]). I nakon toga dobijamo fajl =program.hp= u kome se
    nalaze merenja koja liče na:

    #+CAPTION: haskellNTP/profiling/profiling-exe-basic.hp
    #+INCLUDE: "haskellNTP/profiling/profiling-exe-basic.hp" src fundamental

    za vizualizaciju ovih rezultata može se koristiti program =hp2ps=:

    #+BEGIN_SRC shell
      stack exec -- hp2ps -d program-exe.hp
    #+END_SRC

    Za program:

    #+CAPTION: haskellNTP/profiling/src/Mean.hs
    #+INCLUDE: "haskellNTP/profiling/src/Mean.hs" src haskell :lines "5-"

    #+ATTR_HTML: :width 600px
    [[file:images/profiling-exe-mean.jpg]]

* Haskell Core                                                 :za_radoznale:

  Kada /profiling/ ne daje dovoljno dobar uvid u to šta program radi
  na niskim nivoima onda možda razumevanja /Haskell Core-a/ može da
  pomogne.

  [[https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType][/Haskell Core/]] je "jednostavan funkcionalan jezik" koji /GHC/
  koristi kao /intermediate/ reprezentaciju programa. /GHC/ optimizuje
  programe tako što ih sukcesivno transformiše u sve efikasnije
  forme. /Core/ predstavlja poslednji nivo na kome se očuvavaju
  pravila funkcionalnog programiranja pre prevođenja na imperativni -
  kod niskog nivoa (za šta se kod /GHC/-a koriste [[https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode][/STG/]] i /C--/).

  /Core/ je za razliku od Haskell-a veoma jednostavan jezik. Njegova
  sintaksa se može opisati u 20-ak linija, eksplicitno je tipiziran. I
  /sve konstrukcije u Haskell-u mogu se predstaviti pomoću Core
  jezika/.

  Kako bismo od kompajlera tržili da nam pokaže /Core/ verziju našeg
  programa treba da mu prosledimo opciju =-ddump-simpl= ili da
  koristimo =ghc-core= alat koji to (uz još par stvari) uradi za
  nas. Ako projekat koristi /Stack/ onda se to može uratiti na sledeći
  način:

  Instalirati =ghc-core=:

  #+BEGIN_SRC shell
    stack install ghc-core
  #+END_SRC

  /Stack/ će možda upozoriti da nema specificiranih verzija
  /dependencies/-a ali će dati i predlog šta treba uraditi, npr:

  #+BEGIN_SRC fundamental
    Recommended action: try adding the following to your extra-deps in
    /.../haskellNTP/profiling/stack.yaml:
    - colorize-haskell-1.0.1
  #+END_SRC

  Poslušaćemo predlog i izmeniti odgovarajuću liniju u =stack.yaml=
  projekta na:

  #+BEGIN_SRC yaml
    extra-deps: [colorize-haskell-1.0.1]
  #+END_SRC

  Nakon toga možemo ponovo pokrenuti instalaciju i posle toga:

  #+BEGIN_SRC shell
    stack exec -- ghc-core app/Main.hs
  #+END_SRC

  Što će na terminal ispisati sve transformacije našeg programa pa
  tako možemo ispratiti šta tačno radi kompajler.

  /GHC/ nam omogućuje da ispitujemo sve njegove nivoe kompajliranja pa
  tako i sam asembler na kraju. O tome možete čitati na kraju [[http://book.realworldhaskell.org/read/profiling-and-optimization.html][ovog]]
  poglavlja /Real World Haskell/-a.
* Literatura
  - [[http://learnyouahaskell.com/][Learn Some Haskell For The Great Good]]
  - [[https://wiki.haskell.org/Introduction][Haskell wiki]]
  - [[http://book.realworldhaskell.org/][Real World Haskell]] (odlična knjiga ali nije davno ažurirana)
  - [[http://www.seas.upenn.edu/~cis194/][Kursevi na Pensilvanija univerzitetu]] (/spring13/, /fall16/ ili
    bilo koji drugi po izboru.)

* Footnotes

[fn:3] Ovaj deo je uglavnom preuzet sa [[http://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html][cis194]] (koji svakako
preporučujem u celini :) ).

[fn:2] Izrazi koji imaju sporedne efekte se _veoma_ posebno tretiraju.

[fn:1] Naravno, sve se može ako je čovek dovoljno uporan, samo nije
uvek najpametnije.
